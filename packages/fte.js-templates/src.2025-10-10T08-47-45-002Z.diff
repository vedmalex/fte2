Index: file comparison
===================================================================
--- src
+++ src.compare

## Directory Structure Changes

@@ -1,31 +1,13 @@
 ```
 project
-    ├── __tests__
-    │   ├── async.codeblock.expressions.test.ts
-    │   ├── async.main.template.test.ts
-    │   ├── codeblock.runtime.test.ts
-    │   ├── codeblock.sourcemap.test.ts
-    │   ├── compiled.template.test.ts
-    │   ├── equivalence.extended.test.ts
-    │   ├── extend.alias.require.test.ts
-    │   ├── MainTemplate.basic.test.ts
-    │   ├── MainTemplate.slots.test.ts
-    │   ├── MainTemplate.ts-vs-js.equivalence.test.ts
-    │   ├── sourcemap.positions.test.ts
-    │   ├── sourcemap.stress.lines.test.ts
-    │   ├── stream.abort.test.ts
-    │   ├── stream.coalesce.hwm.test.ts
-    │   ├── stream.deindent.test.ts
-    │   ├── stream.hwm.behavior.test.ts
-    │   ├── stream.main.template.test.ts
-    │   └── stream.options.test.ts
     ├── codeblock.njs.ts
     ├── compilationError.njs.ts
     ├── compiled.njs.ts
     ├── es6module.njs.ts
     ├── es6module.ts.njs.ts
     ├── index.ts
+    ├── index.ts.njs.ts
     ├── MainTemplate.njs.ts
     ├── MainTemplate.ts.njs.ts
     ├── raw.njs.ts
     ├── singlefile.es6.njs.ts


## File Content Changes

diff --git a/MainTemplate.njs.ts b/MainTemplate.njs.ts
index 0000000..0000000
@@ -1,230 +1,161 @@
 import { TemplateBase } from "fte.js-base";
-import { TemplateSourceMapGenerator } from "fte.js-base";
-
-export interface MainTemplateOptions {
-    escapeIt: (str: string) => string;
-    applyIndent: (str: string, indent: string) => string;
-    applyDeindent: (str: string) => string;
-    sourceMap?: boolean;
-    sourceFile?: string;
-    sourceRoot?: string;
-    inline?: boolean;
-    promise?: boolean;
-    stream?: boolean;
-    abort?: any;
-}
-
-export interface MainTemplateResult {
-    code: string;
-    map?: any;
-}
-
 export default {
     alias: [
         "MainTemplate.njs"
     ],
     aliases: {
         "codeblock": "codeblock.njs"
     },
-    script: function(context, _content, partial, slot, options: MainTemplateOptions): MainTemplateResult {
+    script: function(context, _content, partial, slot, options) {
         function content<T>(blockName: string, ctx: T) {
             if (ctx === undefined || ctx === null) ctx = context;
             return _content(blockName, ctx, content, partial, slot);
         }
         var out: Array<string> = [];
-        const { directives } = context;
-
-        // Передаем опции source map в partial
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("export interface MainTemplateOptions {\n");
+        out.push("  escapeIt: (str: string) => string;\n");
+        out.push("  applyIndent: (str: string, indent: string) => string;\n");
+        out.push("  applyDeindent: (str: string) => string;\n");
+        out.push("  sourceMap?: boolean;\n");
+        out.push("  sourceFile?: string;\n");
+        out.push("  sourceRoot?: string;\n");
+        out.push("  inline?: boolean;\n");
+        out.push("}\n");
+        out.push("\n");
+        out.push("export interface MainTemplateResult {\n");
+        out.push("  code: string;\n");
+        out.push("  map?: any;\n");
+        out.push("}\n");
+        out.push("\n");
+        const { directives  } = context;
         const partialOptions = {
             ...options,
             sourceMap: options.sourceMap,
             sourceFile: options.sourceFile,
             sourceRoot: options.sourceRoot,
             inline: options.inline
         };
-
-        // Обрабатываем результат из partial, который теперь может содержать source map
-        const mainResult = partial(context.main, "codeblock", partialOptions);
-        const mainCode = typeof mainResult === 'string' ? mainResult : mainResult.code;
-        if (typeof mainCode !== 'string') {
-            throw new Error("MainTemplate.njs: codeblock returned non-string for main");
-        }
-        const mainMap = typeof mainResult === 'string' ? undefined : mainResult.map;
-
-        out.push("{");
+        out.push("\n");
+        out.push("{\n");
         if (directives.chunks) {
             out.push("\n");
-            out.push("chunks: " + (JSON.stringify(directives.chunks)) + ",");
+            out.push("chunks: " + (JSON.stringify(directives.chunks)) + ",\n");
         }
+        out.push("\n");
         if (directives.alias) {
             out.push("\n");
-            out.push("alias: " + (JSON.stringify(directives.alias)) + ",");
+            out.push("alias: " + (JSON.stringify(directives.alias)) + ",\n");
         }
         out.push("\n");
         out.push("\n");
-        const asyncMode = !!(options as any)?.promise;
-        const streamMode = !!(options as any)?.stream;
-        out.push("script: function (" + (directives.context) + ", _content, partial, slot, options){\n");
-        out.push((options.applyIndent(content("maincontent", directives), "    ")) + "\n");
-        if (streamMode) {
-            out.push("    const __isThenable = v => v && typeof v.then==='function'\n");
-            out.push("    const __ab = options && options.abort\n");
-            if (directives.chunks) {
-                out.push("    const __aiter = async function* (arr){\n");
-                out.push("      const maxSize = options && options.maxCoalesceChunkSize || 0\n");
-                out.push("      let acc=''\n");
-                out.push("      for(const v of arr){ if(__ab && __ab.aborted) return; const sv = (__isThenable(v)? await v : v); if(maxSize>0){ acc += sv; if(acc.length>=maxSize){ yield acc; acc='' } } else { yield sv } }\n");
-                out.push("      if(acc) yield acc\n");
-                out.push("    }\n");
-                out.push("    var out = []\n");
-            } else {
-                out.push("    const __makeQ = ()=>{ const buf=[]; let res; let done=false; const hwm=(options&&options.highWaterMark)||0; return { push: v=>{ buf.push(v); if(res){ res(); res=undefined } if(hwm>0 && buf.length>=hwm){ /* soft backpressure point */ } }, end:()=>{ done=true; if(res){res()} }, async *iter(){ while(true){ if(__ab && __ab.aborted) return; if(buf.length){ const val = buf.shift(); if(options&&options.onChunk) try{ options.onChunk(String(val)) }catch(e){ if(options.onError) options.onError(e) } yield val; continue } if(done) return; await new Promise(r=>res=r) } } }\n");
-                out.push("    const __q = __makeQ()\n");
-                out.push("    var out = { push: v => __isThenable(v) ? v.then(v2=>__q.push(v2)) : __q.push(v) }\n");
-            }
-        } else {
-            out.push("    var out = []\n");
-            if (asyncMode) {
-                out.push("    const __isThenable = v => v && typeof v.then==='function'\n");
-                out.push("    const __aj = async arr => { const a = await Promise.all(Array.from(arr, v => __isThenable(v)? v : Promise.resolve(v))); return Array.isArray(a) ? a.join('') : String(a) }\n");
-            }
-        }
-        out.push((options.applyIndent(content("chunks-start", directives), "    ")) + "\n");
-        out.push("/*__MAIN_START__*/\n");
-        if (asyncMode) {
-            out.push((options.applyIndent("(async ()=>{\n" + String(mainCode) + "\n})().then(v=>{ if(typeof v==='string') out.push(v) })", "    ")) + "\n");
-        } else {
-            out.push((options.applyIndent(String(mainCode), "    ")) + "\n");
-        }
-        out.push("/*__MAIN_END__*/");
-        out.push((options.applyIndent(content("chunks-finish", directives), "    ")));
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("  script: function (" + (directives.context) + ", _content, partial, slot, options: MainTemplateOptions): MainTemplateResult{\n");
+        out.push("    " + (content("maincontent", directives)) + "\n");
+        out.push("    var out = []\n");
+        out.push("\n");
+        out.push("    const partialOptions = {\n");
+        out.push("      ...options,\n");
+        out.push("      sourceMap: options.sourceMap,\n");
+        out.push("      sourceFile: options.sourceFile,\n");
+        out.push("      sourceRoot: options.sourceRoot,\n");
+        out.push("      inline: options.inline,\n");
+        out.push("    }\n");
+        out.push("\n");
+        out.push("    " + (content("chunks-start", directives)) + "\n");
+        out.push("    ");
+        const __main = partial(context.main, "codeblock", partialOptions);
+        out.push("\n");
+        out.push("    " + (typeof __main === "string" ? __main : __main.code) + "\n");
+        out.push("    " + (content("chunks-finish", directives)) + "\n");
+        out.push("    ");
         if (directives.chunks) {
             out.push("\n");
             out.push("    if(out.some(t=>typeof t == 'object')){\n");
-            out.push(asyncMode
-              ? "      return Promise.all(out.map(async chunk => (\n"
-              : "      return out.map(chunk=(\n");
-            out.push("          {...chunk,\n");
-            if (streamMode) {
-                out.push("            content:");
-                if (directives.deindent) {
-                    out.push(" options.applyDeindentStream(");
-                }
-                out.push("\n");
-                out.push("            __aiter(Array.isArray(chunk.content) ? chunk.content : [chunk.content])");
-                if (directives.deindent) {
-                    out.push(")");
-                }
-            } else {
-                out.push("            content:");
-                if (directives.deindent) {
-                    out.push(" options.applyDeindent(");
-                }
-                out.push("\n");
-                out.push(asyncMode
-                  ? "            Array.isArray(chunk.content)\n              ? await __aj(chunk.content)\n              : chunk.content"
-                  : "            Array.isArray(chunk.content)\n              ? chunk.content.join('')\n              : chunk.content");
-                if (directives.deindent) {
-                    out.push(")");
-                }
+            out.push("      return out.map(chunk=>\n");
+            out.push("          ({...chunk,\n");
+            out.push("            content:\n");
+            out.push("            ");
+            if (directives.deindent) {
+                out.push(" options.applyDeindent(");
             }
             out.push("\n");
-            out.push("          }\n");
-            out.push("        )\n");
-            out.push(asyncMode ? "      ))\n" : "      )\n");
-            out.push("    } else {\n");
-            if (asyncMode) {
-                out.push("      return __aj(out)\n");
-            } else {
-                out.push("      return ");
-                if (directives.deindent) {
-                    out.push(" options.applyDeindent(");
-                }
-                out.push("out");
-                if (directives.deindent) {
-                    out.push(")");
-                }
-                out.push(".join('')\n");
+            out.push("            Array.isArray(chunk.content)\n");
+            out.push("              ? chunk.content.join('')\n");
+            out.push("              : chunk.content\n");
+            out.push("            ");
+            if (directives.deindent) {
+                out.push(")");
             }
-            out.push("    }");
-        } else {
             out.push("\n");
-            if (streamMode) {
-                out.push("      __q.end(); ");
-                if (directives.deindent) {
-                    out.push("return options.applyDeindentStream(__q.iter())");
-                } else {
-                    out.push("return __q.iter()");
-                }
-            } else if (asyncMode) {
-                out.push("      return __aj(out)");
-            } else {
-                out.push("      return ");
-                if (directives.deindent) {
-                    out.push(" options.applyDeindent(");
-                }
-                out.push("out");
-                if (directives.deindent) {
-                    out.push(")");
-                }
-                out.push(".join('')");
-            }
+            out.push("          })\n");
+            out.push("      ) as any\n");
+            out.push("    }\n");
+            out.push("    ");
         }
         out.push("\n");
-        out.push("  },");
+        out.push("\n");
+        out.push("    const __mainMap = typeof __main === 'string' ? undefined : __main.map\n");
+        out.push("    const __result = out.join('')\n");
+        out.push("    if (__mainMap) {\n");
+        out.push("      return { code: __result, map: __mainMap }\n");
+        out.push("    }\n");
+        out.push("    return { code: __result }\n");
+        out.push("  },\n");
         const blockNames = Object.keys(context.blocks);
         if (blockNames.length > 0) {
             out.push("\n");
-            out.push("  blocks : {");
+            out.push("  blocks : {\n");
             for(let i = 0; i < blockNames.length; i += 1){
                 const block = context.blocks[blockNames[i]];
                 out.push("\n");
                 out.push('    "' + (blockNames[i]) + '": function(' + (block.directives.context) + ",  _content, partial, slot, options) {\n");
-                out.push((options.applyIndent(content("maincontent", block.directives), "      ")) + "\n");
+                out.push("      " + (content("maincontent", block.directives)) + "\n");
                 out.push("      var out = []\n");
-
-                // Обрабатываем результат из partial для блока
-                const blockResult = partial(block.main, "codeblock", partialOptions);
-                const blockCode = typeof blockResult === 'string' ? blockResult : blockResult.code;
-                if (typeof blockCode !== 'string') { throw new Error("MainTemplate.njs: codeblock returned non-string for block '" + (blockNames[i]) + "'"); }
-                out.push((options.applyIndent(String(blockCode), "      ")));
-
+                out.push("      ");
+                const __block = partial(block.main, "codeblock", partialOptions);
+                out.push("\n");
+                out.push("      " + (typeof __block === "string" ? __block : __block.code) + "\n");
+                out.push("      ");
                 if (directives.chunks) {
                     out.push("\n");
                     out.push("      if(out.some(t=>typeof t == 'object')){\n");
-                    out.push("        return out.map(chunk=>(\n");
-                    out.push("            {...chunk,\n");
-                    out.push("              content:");
+                    out.push("        return out.map(chunk=>\n");
+                    out.push("            ({...chunk,\n");
+                    out.push("              content:\n");
+                    out.push("              ");
                     if (directives.deindent) {
                         out.push(" options.applyDeindent(");
                     }
                     out.push("\n");
                     out.push("              Array.isArray(chunk.content)\n");
                     out.push("                ? chunk.content.join('')\n");
-                    out.push("                : chunk.content");
+                    out.push("                : chunk.content\n");
+                    out.push("              ");
                     if (directives.deindent) {
                         out.push(")");
                     }
                     out.push("\n");
-                    out.push("            }\n");
-                    out.push("          )\n");
+                    out.push("            })\n");
                     out.push("        )\n");
                     out.push("      } else {\n");
-                    if (asyncMode) {
-                        out.push("        return __aj(out)\n");
-                    } else {
-                        out.push("        return ");
-                        if (directives.deindent) {
-                            out.push(" options.applyDeindent(");
-                        }
-                        out.push("out");
-                        if (directives.deindent) {
-                            out.push(")");
-                        }
-                        out.push(".join('')\n");
+                    out.push("        return ");
+                    if (directives.deindent) {
+                        out.push(" options.applyDeindent(");
                     }
-                    out.push("      }");
+                    out.push("out");
+                    if (directives.deindent) {
+                        out.push(")");
+                    }
+                    out.push(".join('')\n");
+                    out.push("      }\n");
+                    out.push("      ");
                 } else {
                     out.push("\n");
                     out.push("        return ");
                     if (directives.deindent) {
@@ -233,68 +164,66 @@
                     out.push("out");
                     if (directives.deindent) {
                         out.push(")");
                     }
-                    out.push(".join('')");
+                    out.push(".join('')\n");
+                    out.push("      ");
                 }
                 out.push("\n");
-                out.push("    },");
+                out.push("    },\n");
             }
             out.push("\n");
-            out.push("  },");
+            out.push("  },\n");
         }
+        out.push("\n");
         const slotNames = Object.keys(context.slots);
         if (slotNames.length > 0) {
             out.push("\n");
-            out.push("  slots : {");
+            out.push("  slots : {\n");
             for(let i = 0; i < slotNames.length; i += 1){
-                const slot = context.slots[slotNames[i]];
+                const slot = context.blocks[slotNames[i]];
                 out.push("\n");
                 out.push('    "' + (slotNames[i]) + '": function(' + (slot.directives.context) + ",  _content, partial, slot, options){\n");
-                out.push((options.applyIndent(content("maincontent", slot.directives), "      ")) + "\n");
+                out.push("      " + (content("maincontent", slot.directives)) + "\n");
                 out.push("      var out = []\n");
-
-                // Обрабатываем результат из partial для слота
-                const slotResult = partial(slot.main, "codeblock", partialOptions);
-                const slotCode = typeof slotResult === 'string' ? slotResult : slotResult.code;
-                if (typeof slotCode !== 'string') { throw new Error("MainTemplate.njs: codeblock returned non-string for slot '" + (slotNames[i]) + "'"); }
-                out.push((options.applyIndent(String(slotCode), "      ")));
-
+                out.push("      ");
+                const __slot = partial(slot.main, "codeblock", partialOptions);
+                out.push("\n");
+                out.push("      " + (typeof __slot === "string" ? __slot : __slot.code) + "\n");
+                out.push("      ");
                 if (directives.chunks) {
                     out.push("\n");
                     out.push("      if(out.some(t=>typeof t == 'object')){\n");
-                    out.push("        return out.map(chunk=>(\n");
-                    out.push("            {...chunk,\n");
-                    out.push("              content:");
+                    out.push("        return out.map(chunk=>\n");
+                    out.push("            ({...chunk,\n");
+                    out.push("              content:\n");
+                    out.push("              ");
                     if (directives.deindent) {
                         out.push(" options.applyDeindent(");
                     }
                     out.push("\n");
                     out.push("              Array.isArray(chunk.content)\n");
                     out.push("                ? chunk.content.join('')\n");
-                    out.push("                : chunk.content");
+                    out.push("                : chunk.content\n");
+                    out.push("              ");
                     if (directives.deindent) {
                         out.push(")");
                     }
                     out.push("\n");
-                    out.push("            }\n");
-                    out.push("          )\n");
+                    out.push("            })\n");
                     out.push("        )\n");
                     out.push("      } else {\n");
-                    if (asyncMode) {
-                        out.push("        return __aj(out)\n");
-                    } else {
-                        out.push("        return ");
-                        if (directives.deindent) {
-                            out.push(" options.applyDeindent(");
-                        }
-                        out.push("out");
-                        if (directives.deindent) {
-                            out.push(")");
-                        }
-                        out.push(".join('')\n");
+                    out.push("        return ");
+                    if (directives.deindent) {
+                        out.push(" options.applyDeindent(");
                     }
-                    out.push("      }");
+                    out.push("out");
+                    if (directives.deindent) {
+                        out.push(")");
+                    }
+                    out.push(".join('')\n");
+                    out.push("      }\n");
+                    out.push("      ");
                 } else {
                     out.push("\n");
                     out.push("        return ");
                     if (directives.deindent) {
@@ -303,138 +232,87 @@
                     out.push("out");
                     if (directives.deindent) {
                         out.push(")");
                     }
-                    out.push(".join('')");
+                    out.push(".join('')\n");
+                    out.push("      ");
                 }
                 out.push("\n");
-                out.push("    },");
+                out.push("    },\n");
             }
             out.push("\n");
-            out.push("  },");
+            out.push("  },\n");
         }
         out.push("\n");
-        out.push("  compile: function() {");
-        if (directives.chunks) {
-            out.push("\n");
-            out.push("    this.chunks = " + (JSON.stringify(directives.chunks)));
-        }
+        out.push("  compile: function() {\n");
         if (directives.alias) {
             out.push("\n");
-            out.push("    this.alias = " + (JSON.stringify(directives.alias)));
+            out.push("    this.alias = " + (JSON.stringify(directives.alias)) + "\n");
         }
+        out.push("\n");
         if (directives.requireAs.length > 0) {
             out.push("\n");
-            out.push("    this.aliases={}");
+            out.push("    this.aliases={}\n");
             var rq;
             for(var i = 0, len = directives.requireAs.length; i < len; i++){
                 rq = directives.requireAs[i];
                 out.push("\n");
                 out.push('    this.aliases["' + (rq.alias) + '"] = "' + (rq.name) + '"\n');
-                out.push('    this.factory.ensure("' + (rq.name) + '")');
+                out.push('    this.factory.ensure("' + (rq.name) + '")\n');
             }
         }
+        out.push("\n");
+        out.push("\n");
         if (directives.extend) {
             out.push("\n");
             out.push("    this.parent = " + (JSON.stringify(directives.extend)) + "\n");
-            out.push("    this.mergeParent(this.factory.ensure(this.parent))");
+            out.push("    this.mergeParent(this.factory.ensure(this.parent))\n");
         }
         out.push("\n");
         out.push("  },\n");
-        out.push("  dependency: {");
+        out.push("  dependency: {\n");
+        out.push("  ");
         if (directives.extend) {
             out.push("\n");
-            out.push((options.applyIndent(JSON.stringify(directives.extend), "    ")) + ": true,");
+            out.push("    " + (JSON.stringify(directives.extend)) + ": true,\n");
+            out.push("  ");
         }
+        out.push("\n");
         if (directives.requireAs.length > 0) {
             for(var i = 0, len = directives.requireAs.length; i < len; i++){
                 rq = directives.requireAs[i];
                 out.push("\n");
                 out.push('    "' + (rq.name) + '": true,\n');
-                out.push('    "' + (rq.alias) + '": true,');
+                out.push('    "' + (rq.alias) + '": true,\n');
             }
         }
         out.push("\n");
         out.push("  }\n");
         out.push("}");
-
-        let result = out.join("");
-
-        // Если у нас есть source map от основного контента, расширяем его до всего результата
-        if (mainMap) {
-            const startMarker = "/*__MAIN_START__*/\n";
-            const endMarker = "/*__MAIN_END__*/";
-            const startIdx = result.indexOf(startMarker);
-            const endIdx = result.indexOf(endMarker);
-            const totalLines = result.split(/\r?\n/).length;
-            const prefixLines = startIdx >= 0 ? result.slice(0, startIdx).split(/\r?\n/).length : 0;
-            const indentColumns = 4; // we applyIndent with 4 spaces
-
-            // Remove markers from code
-            result = result.replace(startMarker, "").replace(endMarker, "");
-
-            const gen = new TemplateSourceMapGenerator({
-                file: options.sourceFile,
-                sourceRoot: options.sourceRoot,
-            });
-
-            const primarySource = Array.isArray((mainMap as any).sources) && (mainMap as any).sources.length
-                ? (mainMap as any).sources[0]
-                : 'template.njs';
-
-            // Map every line start to ensure dense mapping lines
-            for (let i = 1; i <= totalLines; i += 1) {
-                gen.addSegment({
-                    generatedLine: i,
-                    generatedColumn: 0,
-                    originalLine: 1,
-                    originalColumn: 0,
-                    source: primarySource,
-                    name: undefined,
-                    content: undefined as any,
-                } as any);
-            }
-
-            // Re-emit specific segments from inner main map with line/column shift
-            const segs = (mainMap as any)?.template?.segments || [];
-            if (Array.isArray(segs)) {
-                for (const s of segs) {
-                    gen.addSegment({
-                        generatedLine: prefixLines + s.generatedLine,
-                        generatedColumn: indentColumns + (s.generatedColumn || 0),
-                        originalLine: s.originalLine,
-                        originalColumn: s.originalColumn,
-                        source: s.source,
-                        name: s.name,
-                        content: s.content,
-                    });
-                }
-            }
-
-            return {
-                code: result,
-                map: gen.toJSON(),
-            };
-        }
-
-        return {
-            code: result
-        };
+        return out.join("");
     },
     blocks: {
         "maincontent": function(directives, _content, partial, slot, options) {
             var out: Array<string> = [];
+            out.push("\n");
+            out.push("\n");
+            out.push("\n");
             if (directives?.content) {
+                out.push("\n");
                 out.push("function content(blockName, ctx) {\n");
                 out.push("  if(ctx === undefined || ctx === null) ctx = " + (directives.context) + "\n");
                 out.push("  return _content(blockName, ctx, content, partial, slot)\n");
-                out.push("}");
+                out.push("}\n");
             }
             out.push("");
             return out.join("");
         },
         "chunks-start": function(directives, _content, partial, slot, options) {
             var out: Array<string> = [];
+            out.push("\n");
+            out.push("  " + "\n");
+            out.push("  " + "\n");
+            out.push("  ");
             if (directives.chunks) {
                 out.push("\n");
                 out.push("const _partial = partial\n");
                 out.push("partial = function(obj, template) {\n");
@@ -471,35 +349,49 @@
                 out.push("  result[current].push(...out)\n");
                 out.push("  out = []\n");
                 out.push("  current = outStack.pop() || main\n");
                 out.push("}\n");
-                out.push("chunkStart(main)");
+                out.push("chunkStart(main)\n");
             }
             out.push("");
             return out.join("");
         },
         "chunks-finish": function(directives, _content, partial, slot, options) {
             var out: Array<string> = [];
+            out.push("\n");
+            out.push("  " + "\n");
+            out.push("  " + "\n");
+            out.push("  ");
             if (directives.chunks) {
                 out.push("\n");
-                out.push("    chunkEnd()");
+                out.push("    chunkEnd()\n");
+                out.push("    ");
                 if (!directives.useHash) {
                     out.push("\n");
-                    out.push("    out = Object.keys(result)");
+                    out.push("    out = Object.keys(result)\n");
+                    out.push("      ");
                     if (!directives.includeMainChunk) {
                         out.push("\n");
-                        out.push("      .filter(i => i !== '" + (directives.chunks) + "')");
+                        out.push("      .filter(i => i !== '" + (directives.chunks) + "')\n");
+                        out.push("      ");
                     }
                     out.push("\n");
-                    out.push("      .map(curr => ({ name: curr, content: result[curr] }))");
+                    out.push("      .map(curr => ({ name: curr, content: result[curr] }))\n");
+                    out.push("      ");
                 } else {
                     out.push("\n");
-                    out.push("    out = result");
+                    out.push("    out = result\n");
+                    out.push("      ");
                     if (!directives.includeMainChunk) {
                         out.push("\n");
-                        out.push("    delete out['" + (directives.chunks) + "']");
+                        out.push("    delete out['" + (directives.chunks) + "']\n");
+                        out.push("      ");
                     }
+                    out.push("\n");
+                    out.push("    ");
                 }
+                out.push("\n");
+                out.push("  ");
             }
             out.push("");
             return out.join("");
         }


diff --git a/MainTemplate.ts.njs.ts b/MainTemplate.ts.njs.ts
index 0000000..0000000
@@ -11,130 +11,150 @@
             if (ctx === undefined || ctx === null) ctx = context;
             return _content(blockName, ctx, content, partial, slot);
         }
         var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
         const { directives  } = context;
-
-        // Pass sourcemap options to partial
         const partialOptions = {
             ...options,
             sourceMap: options.sourceMap,
             sourceFile: options.sourceFile,
             sourceRoot: options.sourceRoot,
             inline: options.inline
-        } as any;
-
-        // Unwrap partial result which can be string or {code,map}
-        const mainResult: any = partial(context.main, "codeblock", partialOptions);
-        const mainCode: string = typeof mainResult === 'string' ? mainResult : mainResult.code;
-        out.push("{");
+        };
+        out.push("\n");
+        out.push("{\n");
         if (directives.chunks) {
             out.push("\n");
-            out.push("chunks: " + (JSON.stringify(directives.chunks)) + ",");
+            out.push("chunks: " + (JSON.stringify(directives.chunks)) + ",\n");
         }
+        out.push("\n");
         if (directives.alias) {
             out.push("\n");
-            out.push("alias: " + (JSON.stringify(directives.alias)) + ",");
+            out.push("alias: " + (JSON.stringify(directives.alias)) + ",\n");
         }
+        out.push("\n");
         if (directives.requireAs.length > 0) {
             out.push("\n");
-            out.push("aliases: {");
+            out.push("aliases: {\n");
             var rq;
             for(var i = 0, len = directives.requireAs.length; i < len; i++){
                 rq = directives.requireAs[i];
                 out.push("\n");
-                out.push('    "' + (rq.alias) + '": "' + (rq.name) + '",');
+                out.push('    "' + (rq.alias) + '": "' + (rq.name) + '",\n');
             }
             out.push("\n");
             out.push("},\n");
         }
         out.push("\n");
         out.push("\n");
-        out.push("script: function (" + (directives.context) + ", _content, partial, slot, options){\n");
-        out.push((options.applyIndent(content("maincontent", directives), "    ")) + "\n");
+        out.push("export interface MainTemplateOptions {\n");
+        out.push("  escapeIt: (str: string) => string;\n");
+        out.push("  applyIndent: (str: string, indent: string) => string;\n");
+        out.push("  applyDeindent: (str: string) => string;\n");
+        out.push("  sourceMap?: boolean;\n");
+        out.push("  sourceFile?: string;\n");
+        out.push("  sourceRoot?: string;\n");
+        out.push("  inline?: boolean;\n");
+        out.push("}\n");
+        out.push("\n");
+        out.push("export interface MainTemplateResult {\n");
+        out.push("  code: string;\n");
+        out.push("  map?: any;\n");
+        out.push("}\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("  script: function (" + (directives.context) + ", _content, partial, slot, options: MainTemplateOptions): MainTemplateResult{\n");
+        out.push("    " + (content("maincontent", directives)) + "\n");
         out.push("    var out: Array<string> = []\n");
-        out.push((options.applyIndent(content("chunks-start", directives), "    ")) + "\n");
-        if (typeof mainCode !== 'string') { throw new Error("MainTemplate.ts.njs: codeblock returned non-string for main"); }
-        out.push((options.applyIndent(String(mainCode), "    ")) + "\n");
-        out.push((options.applyIndent(content("chunks-finish", directives), "    ")));
+        out.push("\n");
+        out.push("    const partialOptions = {\n");
+        out.push("      ...options,\n");
+        out.push("      sourceMap: options.sourceMap,\n");
+        out.push("      sourceFile: options.sourceFile,\n");
+        out.push("      sourceRoot: options.sourceRoot,\n");
+        out.push("      inline: options.inline,\n");
+        out.push("    }\n");
+        out.push("\n");
+        out.push("    " + (content("chunks-start", directives)) + "\n");
+        out.push("    ");
+        const __main = partial(context.main, "codeblock", partialOptions);
+        out.push("\n");
+        out.push("    " + (typeof __main === "string" ? __main : __main.code) + "\n");
+        out.push("    " + (content("chunks-finish", directives)) + "\n");
+        out.push("    ");
         if (directives.chunks) {
             out.push("\n");
             out.push("    if(out.some(t=>typeof t == 'object')){\n");
-            out.push("      return out.map(chunk=>(\n");
-            out.push("          {...chunk,\n");
-            out.push("            content:");
+            out.push("      return out.map(chunk=>\n");
+            out.push("          ({...chunk,\n");
+            out.push("            content:\n");
+            out.push("            ");
             if (directives.deindent) {
                 out.push(" options.applyDeindent(");
             }
             out.push("\n");
             out.push("            Array.isArray(chunk.content)\n");
             out.push("              ? chunk.content.join('')\n");
-            out.push("              : chunk.content");
+            out.push("              : chunk.content\n");
+            out.push("            ");
             if (directives.deindent) {
                 out.push(")");
             }
             out.push("\n");
-            out.push("          }\n");
-            out.push("        )\n");
-            out.push("      )\n");
-            out.push("    } else {\n");
-            out.push("      return ");
-            if (directives.deindent) {
-                out.push(" options.applyDeindent(");
-            }
-            out.push("out");
-            if (directives.deindent) {
-                out.push(")");
-            }
-            out.push(".join('')\n");
-            out.push("    }");
-        } else {
-            out.push("\n");
-            out.push("      return ");
-            if (directives.deindent) {
-                out.push(" options.applyDeindent(");
-            }
-            out.push("out");
-            if (directives.deindent) {
-                out.push(")");
-            }
-            out.push(".join('')");
+            out.push("          })\n");
+            out.push("      ) as any\n");
+            out.push("    }\n");
+            out.push("    ");
         }
         out.push("\n");
-        out.push("  },");
+        out.push("\n");
+        out.push("    const __mainMap = typeof __main === 'string' ? undefined : __main.map\n");
+        out.push("    const __result = out.join('')\n");
+        out.push("    if (__mainMap) {\n");
+        out.push("      return { code: __result, map: __mainMap }\n");
+        out.push("    }\n");
+        out.push("    return { code: __result }\n");
+        out.push("  },\n");
         const blockNames = Object.keys(context.blocks);
         if (blockNames.length > 0) {
             out.push("\n");
-            out.push("  blocks : {");
+            out.push("  blocks : {\n");
             for(let i = 0; i < blockNames.length; i += 1){
                 const block = context.blocks[blockNames[i]];
                 out.push("\n");
                 out.push('    "' + (blockNames[i]) + '": function(' + (block.directives.context) + ",  _content, partial, slot, options) {\n");
-                out.push((options.applyIndent(content("maincontent", block.directives), "      ")) + "\n");
+                out.push("      " + (content("maincontent", block.directives)) + "\n");
                 out.push("      var out: Array<string> = []\n");
-                const blockResult: any = partial(block.main, "codeblock", partialOptions);
-                const blockCode: string = typeof blockResult === 'string' ? blockResult : blockResult.code;
-                if (typeof blockCode !== 'string') { throw new Error("MainTemplate.ts.njs: codeblock returned non-string for block '" + (blockNames[i]) + "'"); }
-                out.push((options.applyIndent(String(blockCode), "      ")));
+                out.push("      ");
+                const __block = partial(block.main, "codeblock", partialOptions);
+                out.push("\n");
+                out.push("      " + (typeof __block === "string" ? __block : __block.code) + "\n");
+                out.push("      ");
                 if (directives.chunks) {
                     out.push("\n");
                     out.push("      if(out.some(t=>typeof t == 'object')){\n");
-                    out.push("        return out.map(chunk=>(\n");
-                    out.push("            {...chunk,\n");
-                    out.push("              content:");
+                    out.push("        return out.map(chunk=>\n");
+                    out.push("            ({...chunk,\n");
+                    out.push("              content:\n");
+                    out.push("              ");
                     if (directives.deindent) {
                         out.push(" options.applyDeindent(");
                     }
                     out.push("\n");
                     out.push("              Array.isArray(chunk.content)\n");
                     out.push("                ? chunk.content.join('')\n");
-                    out.push("                : chunk.content");
+                    out.push("                : chunk.content\n");
+                    out.push("              ");
                     if (directives.deindent) {
                         out.push(")");
                     }
                     out.push("\n");
-                    out.push("            }\n");
-                    out.push("          )\n");
+                    out.push("            })\n");
                     out.push("        )\n");
                     out.push("      } else {\n");
                     out.push("        return ");
                     if (directives.deindent) {
@@ -144,9 +164,10 @@
                     if (directives.deindent) {
                         out.push(")");
                     }
                     out.push(".join('')\n");
-                    out.push("      }");
+                    out.push("      }\n");
+                    out.push("      ");
                 } else {
                     out.push("\n");
                     out.push("        return ");
                     if (directives.deindent) {
@@ -155,49 +176,53 @@
                     out.push("out");
                     if (directives.deindent) {
                         out.push(")");
                     }
-                    out.push(".join('')");
+                    out.push(".join('')\n");
+                    out.push("      ");
                 }
                 out.push("\n");
-                out.push("    },");
+                out.push("    },\n");
             }
             out.push("\n");
-            out.push("  },");
+            out.push("  },\n");
         }
+        out.push("\n");
         const slotNames = Object.keys(context.slots);
         if (slotNames.length > 0) {
             out.push("\n");
-            out.push("  slots : {");
+            out.push("  slots : {\n");
             for(let i = 0; i < slotNames.length; i += 1){
                 const slot = context.blocks[slotNames[i]];
                 out.push("\n");
                 out.push('    "' + (slotNames[i]) + '": function(' + (slot.directives.context) + ",  _content, partial, slot, options){\n");
-                out.push((options.applyIndent(content("maincontent", slot.directives), "      ")) + "\n");
+                out.push("      " + (content("maincontent", slot.directives)) + "\n");
                 out.push("      var out: Array<string> = []\n");
-                const slotResult: any = partial(slot.main, "codeblock", partialOptions);
-                const slotCode: string = typeof slotResult === 'string' ? slotResult : slotResult.code;
-                if (typeof slotCode !== 'string') { throw new Error("MainTemplate.ts.njs: codeblock returned non-string for slot '" + (slotNames[i]) + "'"); }
-                out.push((options.applyIndent(String(slotCode), "      ")));
+                out.push("      ");
+                const __slot = partial(slot.main, "codeblock", partialOptions);
+                out.push("\n");
+                out.push("      " + (typeof __slot === "string" ? __slot : __slot.code) + "\n");
+                out.push("      ");
                 if (directives.chunks) {
                     out.push("\n");
                     out.push("      if(out.some(t=>typeof t == 'object')){\n");
-                    out.push("        return out.map(chunk=>(\n");
-                    out.push("            {...chunk,\n");
-                    out.push("              content:");
+                    out.push("        return out.map(chunk=>\n");
+                    out.push("            ({...chunk,\n");
+                    out.push("              content:\n");
+                    out.push("              ");
                     if (directives.deindent) {
                         out.push(" options.applyDeindent(");
                     }
                     out.push("\n");
                     out.push("              Array.isArray(chunk.content)\n");
                     out.push("                ? chunk.content.join('')\n");
-                    out.push("                : chunk.content");
+                    out.push("                : chunk.content\n");
+                    out.push("              ");
                     if (directives.deindent) {
                         out.push(")");
                     }
                     out.push("\n");
-                    out.push("            }\n");
-                    out.push("          )\n");
+                    out.push("            })\n");
                     out.push("        )\n");
                     out.push("      } else {\n");
                     out.push("        return ");
                     if (directives.deindent) {
@@ -207,9 +232,10 @@
                     if (directives.deindent) {
                         out.push(")");
                     }
                     out.push(".join('')\n");
-                    out.push("      }");
+                    out.push("      }\n");
+                    out.push("      ");
                 } else {
                     out.push("\n");
                     out.push("        return ");
                     if (directives.deindent) {
@@ -218,74 +244,80 @@
                     out.push("out");
                     if (directives.deindent) {
                         out.push(")");
                     }
-                    out.push(".join('')");
+                    out.push(".join('')\n");
+                    out.push("      ");
                 }
                 out.push("\n");
-                out.push("    },");
+                out.push("    },\n");
             }
             out.push("\n");
-            out.push("  },");
+            out.push("  },\n");
         }
         out.push("\n");
-        out.push("  compile: function(this: TemplateBase) {");
-        if (directives.chunks) {
-            out.push("\n");
-            out.push("    this.chunks = " + (JSON.stringify(directives.chunks)));
-        }
+        out.push("  compile: function(this: TemplateBase) {\n");
         if (directives.requireAs.length > 0) {
+            out.push("\n");
             var rq;
             for(var i = 0, len = directives.requireAs.length; i < len; i++){
                 rq = directives.requireAs[i];
                 out.push("\n");
-                out.push('    this.factory.ensure("' + (rq.name) + '")');
+                out.push('    this.factory.ensure("' + (rq.name) + '")\n');
             }
             out.push("\n");
         }
+        out.push("\n");
         if (directives.extend) {
             out.push("\n");
             out.push("    this.parent = " + (JSON.stringify(directives.extend)) + "\n");
-            out.push("    this.mergeParent(this.factory.ensure(this.parent))");
+            out.push("    this.mergeParent(this.factory.ensure(this.parent))\n");
         }
         out.push("\n");
         out.push("  },\n");
-        out.push("  dependency: {");
+        out.push("  dependency: {\n");
+        out.push("  ");
         if (directives.extend) {
             out.push("\n");
-            out.push((options.applyIndent(JSON.stringify(directives.extend), "    ")) + ": true,");
+            out.push("    " + (JSON.stringify(directives.extend)) + ": true,\n");
+            out.push("  ");
         }
+        out.push("\n");
         if (directives.requireAs.length > 0) {
             for(var i = 0, len = directives.requireAs.length; i < len; i++){
                 rq = directives.requireAs[i];
                 out.push("\n");
                 out.push('    "' + (rq.name) + '": true,\n');
-                out.push('    "' + (rq.alias) + '": true,');
+                out.push('    "' + (rq.alias) + '": true,\n');
             }
         }
         out.push("\n");
         out.push("  }\n");
         out.push("}");
-        const result = out.join("");
-        if (mainResult && typeof mainResult !== 'string' && mainResult.map) {
-            return { code: result, map: mainResult.map } as any;
-        }
-        return { code: result } as any;
+        return out.join("");
     },
     blocks: {
         "maincontent": function(directives, _content, partial, slot, options) {
             var out: Array<string> = [];
+            out.push("\n");
+            out.push("\n");
+            out.push("\n");
             if (directives?.content) {
+                out.push("\n");
                 out.push("function content<T>(blockName:string, ctx:T) {\n");
                 out.push("  if(ctx === undefined || ctx === null) ctx = " + (directives.context) + "\n");
                 out.push("  return _content(blockName, ctx, content, partial, slot)\n");
-                out.push("}");
+                out.push("}\n");
             }
             out.push("");
             return out.join("");
         },
         "chunks-start": function(directives, _content, partial, slot, options) {
             var out: Array<string> = [];
+            out.push("\n");
+            out.push("  " + "\n");
+            out.push("  " + "\n");
+            out.push("  ");
             if (directives.chunks) {
                 out.push("\n");
                 out.push("const _partial = partial\n");
                 out.push("partial = function(obj, template:string) {\n");
@@ -322,35 +354,49 @@
                 out.push("  result[current].push(...out)\n");
                 out.push("  out = []\n");
                 out.push("  current = outStack.pop() || main\n");
                 out.push("}\n");
-                out.push("chunkStart(main)");
+                out.push("chunkStart(main)\n");
             }
             out.push("");
             return out.join("");
         },
         "chunks-finish": function(directives, _content, partial, slot, options) {
             var out: Array<string> = [];
+            out.push("\n");
+            out.push("  " + "\n");
+            out.push("  " + "\n");
+            out.push("  ");
             if (directives.chunks) {
                 out.push("\n");
-                out.push("    chunkEnd()");
+                out.push("    chunkEnd()\n");
+                out.push("    ");
                 if (!directives.useHash) {
                     out.push("\n");
-                    out.push("    out = Object.keys(result)");
+                    out.push("    out = Object.keys(result)\n");
+                    out.push("      ");
                     if (!directives.includeMainChunk) {
                         out.push("\n");
-                        out.push("      .filter(i => i !== '" + (directives.chunks) + "')");
+                        out.push("      .filter(i => i !== '" + (directives.chunks) + "')\n");
+                        out.push("      ");
                     }
                     out.push("\n");
-                    out.push("      .map(curr => ({ name: curr, content: result[curr] }))");
+                    out.push("      .map(curr => ({ name: curr, content: result[curr] }))\n");
+                    out.push("      ");
                 } else {
                     out.push("\n");
-                    out.push("    out = result");
+                    out.push("    out = result\n");
+                    out.push("      ");
                     if (!directives.includeMainChunk) {
                         out.push("\n");
-                        out.push("    delete out['" + (directives.chunks) + "']");
+                        out.push("    delete out['" + (directives.chunks) + "']\n");
+                        out.push("      ");
                     }
+                    out.push("\n");
+                    out.push("    ");
                 }
+                out.push("\n");
+                out.push("  ");
             }
             out.push("");
             return out.join("");
         }


diff --git a/__tests__/MainTemplate.basic.test.ts b/__tests__/MainTemplate.basic.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/MainTemplate.basic.test.ts
+++ /dev/null
@@ -1,106 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  return F
-}
-
-function textBlock(content: string, withEol = true) {
-  return [{ type: 'text', content, eol: withEol }] as any
-}
-
-describe('MainTemplate.njs - basic generation', () => {
-  test('generates code with main content and no chunks', () => {
-    const F = makeFactory()
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-      },
-      blocks: {},
-      slots: {},
-      main: textBlock('Hello'),
-    }
-
-    const res: any = F.run(ctx, 'MainTemplate.njs')
-    expect(typeof res).toBe('object')
-    expect(typeof res.code).toBe('string')
-
-    expect(res.code).toContain('script: function (context, _content, partial, slot, options)')
-    // Last block has eol cleared by template, so no \n
-    expect(res.code).toContain('out.push("Hello");')
-    expect(res.map).toBeUndefined()
-  })
-
-  test('includes blocks section when blocks are defined', () => {
-    const F = makeFactory()
-
-    const header = {
-      directives: {
-        context: 'ctx',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-      },
-      main: textBlock('Header'),
-    }
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: { header },
-        slots: {},
-      },
-      blocks: { header },
-      slots: {},
-      main: textBlock('Body'),
-    }
-
-    const res: any = F.run(ctx, 'MainTemplate.njs')
-    expect(res.code).toContain('blocks : {')
-    expect(res.code).toContain('"header": function(')
-    expect(res.code).toContain('out.push("Header");')
-  })
-
-  test('adds chunk infrastructure when chunks directive is provided', () => {
-    const F = makeFactory()
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: 'main',
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-        includeMainChunk: false,
-        useHash: false,
-      },
-      blocks: {},
-      slots: {},
-      main: textBlock('X'),
-    }
-
-    const res: any = F.run(ctx, 'MainTemplate.njs')
-    expect(res.code).toContain('const _partial = partial')
-    expect(res.code).toContain('function chunkStart(')
-    expect(res.code).toContain("if(out.some(t=>typeof t == 'object')){")
-  })
-})

diff --git a/__tests__/MainTemplate.slots.test.ts b/__tests__/MainTemplate.slots.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/MainTemplate.slots.test.ts
+++ /dev/null
@@ -1,90 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  return F
-}
-
-function textBlock(content: string, withEol = true) {
-  return [{ type: 'text', content, eol: withEol }] as any
-}
-
-describe('MainTemplate.njs - slots generation', () => {
-  test('includes slots section when slots are defined', () => {
-    const F = makeFactory()
-
-    const footer = {
-      directives: {
-        context: 'ctx',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-      },
-      main: textBlock('Footer'),
-    }
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: { footer },
-        slots: { footer },
-      },
-      blocks: { footer },
-      slots: { footer },
-      main: textBlock('Body'),
-    }
-
-    const res: any = F.run(ctx, 'MainTemplate.njs')
-    expect(typeof res).toBe('object')
-    expect(res.code).toContain('slots : {')
-    expect(res.code).toContain('"footer": function(')
-    expect(res.code).toContain('out.push("Footer");')
-  })
-
-  test('slot function emits chunk plumbing when top-level chunks is set', () => {
-    const F = makeFactory()
-
-    const aside = {
-      directives: {
-        context: 'a',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-      },
-      main: textBlock('A'),
-    }
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: 'main',
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: { aside },
-        slots: { aside },
-        includeMainChunk: false,
-        useHash: false,
-      },
-      blocks: { aside },
-      slots: { aside },
-      main: textBlock('Body'),
-    }
-
-    const res: any = F.run(ctx, 'MainTemplate.njs')
-    expect(res.code).toContain('slots : {')
-    expect(res.code).toContain('"aside": function(')
-    expect(res.code).toContain("if(out.some(t=>typeof t == 'object')){")
-  })
-})

diff --git a/__tests__/MainTemplate.ts-vs-js.equivalence.test.ts b/__tests__/MainTemplate.ts-vs-js.equivalence.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/MainTemplate.ts-vs-js.equivalence.test.ts
+++ /dev/null
@@ -1,167 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  return F
-}
-
-function textBlock(content: string, withEol = true) {
-  return [{ type: 'text', content, eol: withEol }] as any
-}
-
-function getCode(res: any): string {
-  return typeof res === 'string' ? res : res.code
-}
-
-describe('MainTemplate.ts.njs vs MainTemplate.njs - structural equivalence', () => {
-  test('basic script generation without blocks/slots/chunks', () => {
-    const F = makeFactory()
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-      },
-      blocks: {},
-      slots: {},
-      main: textBlock('Hello'),
-    }
-
-    const jsRes: any = F.run(ctx, 'MainTemplate.njs')
-    const tsRes: any = F.run(ctx, 'MainTemplate.ts.njs')
-
-    const jsCode = getCode(jsRes)
-    const tsCode = getCode(tsRes)
-
-    expect(jsCode).toContain('script: function (context, _content, partial, slot, options)')
-    expect(tsCode).toContain('script: function (context, _content, partial, slot, options)')
-
-    expect(jsCode).toContain('out.push("Hello");')
-    expect(tsCode).toContain('out.push("Hello");')
-
-    expect(jsCode).not.toContain('blocks : {')
-    expect(tsCode).not.toContain('blocks : {')
-    expect(jsCode).not.toContain('slots : {')
-    expect(tsCode).not.toContain('slots : {')
-  })
-
-  test('blocks presence and body insertion', () => {
-    const F = makeFactory()
-
-    const header = {
-      directives: {
-        context: 'ctx',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-      },
-      main: textBlock('Header'),
-    }
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: { header },
-        slots: {},
-      },
-      blocks: { header },
-      slots: {},
-      main: textBlock('Body'),
-    }
-
-    const jsCode = getCode(F.run(ctx, 'MainTemplate.njs'))
-    const tsCode = getCode(F.run(ctx, 'MainTemplate.ts.njs'))
-
-    for (const code of [jsCode, tsCode]) {
-      expect(code).toContain('blocks : {')
-      expect(code).toContain('"header": function(')
-      expect(code).toContain('out.push("Header");')
-    }
-  })
-
-  test('slots presence and body insertion', () => {
-    const F = makeFactory()
-
-    const footer = {
-      directives: {
-        context: 'ctx',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-      },
-      main: textBlock('Footer'),
-    }
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: { footer },
-        slots: { footer },
-      },
-      blocks: { footer },
-      slots: { footer },
-      main: textBlock('Body'),
-    }
-
-    const jsCode = getCode(F.run(ctx, 'MainTemplate.njs'))
-    const tsCode = getCode(F.run(ctx, 'MainTemplate.ts.njs'))
-
-    for (const code of [jsCode, tsCode]) {
-      expect(code).toContain('slots : {')
-      expect(code).toContain('"footer": function(')
-      expect(code).toContain('out.push("Footer");')
-    }
-  })
-
-  test('chunks plumbing exists in both when chunks directive is provided', () => {
-    const F = makeFactory()
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: 'main',
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-        includeMainChunk: false,
-        useHash: false,
-      },
-      blocks: {},
-      slots: {},
-      main: textBlock('X'),
-    }
-
-    const jsCode = getCode(F.run(ctx, 'MainTemplate.njs'))
-    const tsCode = getCode(F.run(ctx, 'MainTemplate.ts.njs'))
-
-    for (const code of [jsCode, tsCode]) {
-      expect(code).toContain('const _partial = partial')
-      expect(code).toContain('function chunkStart(')
-      expect(code).toContain("if(out.some(t=>typeof t == 'object')){")
-    }
-  })
-})

diff --git a/__tests__/async.codeblock.expressions.test.ts b/__tests__/async.codeblock.expressions.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/async.codeblock.expressions.test.ts
+++ /dev/null
@@ -1,57 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  // enable promise mode in compiler output
-  F.options = { ...(F.options as any), promise: true } as any
-  return F
-}
-
-function runGenerated(code: string, options: any, vars: Record<string, any>) {
-  const fn = new Function('options', ...Object.keys(vars), `var out=[];\n${code};\nreturn out`)
-  return fn(options, ...Object.values(vars))
-}
-
-describe('async expressions/uexpressions in codeblock', () => {
-  test('expression returns Promise resolved and joined', async () => {
-    const F = makeFactory()
-    const blocks = [
-      { type: 'text', content: 'A', eol: false },
-      { type: 'expression', content: 'promiseName', start: true, end: true, eol: false },
-      { type: 'text', content: 'Z', eol: true },
-    ] as any
-
-    const res: any = F.run(blocks, 'codeblock.njs')
-    const out = runGenerated(res.code, {
-      escapeIt: (s: string) => s,
-      applyIndent: (s: string) => s,
-      applyDeindent: (s: string) => s,
-    }, {
-      promiseName: Promise.resolve('X'),
-    })
-
-    const final = (await Promise.all(out.map((v: any) => (v && typeof v.then === 'function') ? v : Promise.resolve(v)))).join('')
-    expect(final).toBe('AXZ')
-  })
-
-  test('uexpression returns Promise and goes through escape/indent', async () => {
-    const F = makeFactory()
-    const blocks = [
-      { type: 'text', content: 'Hi ', eol: false },
-      { type: 'uexpression', content: 'promiseName', start: true, end: true, eol: true, indent: '  ' },
-    ] as any
-
-    const res: any = F.run(blocks, 'codeblock.njs')
-    const out = runGenerated(res.code, {
-      escapeIt: (s: string) => `[${s}]`,
-      applyIndent: (s: string, i: string) => i + s,
-      applyDeindent: (s: string) => s,
-    }, {
-      promiseName: Promise.resolve('name'),
-    })
-
-    const final = (await Promise.all(out.map((v: any) => (v && typeof v.then === 'function') ? v : Promise.resolve(v)))).join('')
-    expect(final).toBe('Hi   [name]')
-  })
-})

diff --git a/__tests__/async.main.template.test.ts b/__tests__/async.main.template.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/async.main.template.test.ts
+++ /dev/null
@@ -1,135 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  F.options = { ...(F.options as any), promise: true } as any
-  return F
-}
-
-function text(content: string, eol = true) {
-  return [{ type: 'text', content, eol }] as any
-}
-
-describe('MainTemplate.njs async mode', () => {
-  test('awaits promise expressions and joins with __aj', async () => {
-    const F = makeFactory()
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-      },
-      blocks: {},
-      slots: {},
-      main: [
-        { type: 'text', content: 'A', eol: false },
-        { type: 'expression', content: 'context.promiseName', start: true, end: true, eol: false },
-        { type: 'text', content: 'Z', eol: true },
-      ] as any,
-    }
-
-    const res: any = F.run(ctx, 'MainTemplate.njs')
-    const cfg = typeof res === 'string' ? eval('(' + res + ')') : eval('(' + res.code + ')')
-
-    const Local = new TemplateFactoryStandalone({ 'x.njs': cfg } as any)
-    Local.options = { ...(Local.options as any), promise: true } as any
-
-    const html = await Local.runAsync({ promiseName: Promise.resolve('X') } as any, 'x.njs')
-    expect(typeof html).toBe('string')
-    expect(html).toBe('AXZ')
-  })
-
-  test('partials that return Promise are awaited', async () => {
-    const F = makeFactory()
-
-    const part: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-      },
-      blocks: {},
-      slots: {},
-      main: [
-        { type: 'text', content: 'P', eol: false },
-        { type: 'expression', content: 'Promise.resolve("Q")', start: true, end: true, eol: false },
-      ] as any,
-    }
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-      },
-      blocks: {},
-      slots: {},
-      main: [
-        { type: 'expression', content: "partial(context, 'part.njs')", start: true, end: true, eol: true },
-      ] as any,
-    }
-
-    const corePart: any = F.run(part, 'MainTemplate.njs')
-    const coreMain: any = F.run(ctx, 'MainTemplate.njs')
-
-    const cfgPart = typeof corePart === 'string' ? eval('(' + corePart + ')') : eval('(' + corePart.code + ')')
-    const cfgMain = typeof coreMain === 'string' ? eval('(' + coreMain + ')') : eval('(' + coreMain.code + ')')
-
-    const Local = new TemplateFactoryStandalone({ 'main.njs': cfgMain, 'part.njs': cfgPart } as any)
-    Local.options = { ...(Local.options as any), promise: true } as any
-
-    const html = await Local.runAsync({} as any, 'main.njs')
-    expect(typeof html).toBe('string')
-    expect(html).toBe('PQ')
-  })
-
-  test('slots with Promise content are joined', async () => {
-    const F = makeFactory()
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-      },
-      blocks: {},
-      slots: {},
-      main: [
-        { type: 'text', content: 'S', eol: false },
-        { type: 'expression', content: "slot('a', [Promise.resolve('L')])", start: true, end: true, eol: false },
-      ] as any,
-    }
-
-    const res: any = F.run(ctx, 'MainTemplate.njs')
-    const cfg = typeof res === 'string' ? eval('(' + res + ')') : eval('(' + res.code + ')')
-
-    const Local = new TemplateFactoryStandalone({ 'x.njs': cfg } as any)
-    Local.options = { ...(Local.options as any), promise: true } as any
-
-    const html = await Local.runAsync({} as any, 'x.njs')
-    expect(typeof html).toBe('string')
-    expect(html).toBe('S')
-  })
-})

diff --git a/__tests__/codeblock.runtime.test.ts b/__tests__/codeblock.runtime.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/codeblock.runtime.test.ts
+++ /dev/null
@@ -1,54 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  return F
-}
-
-describe('codeblock.njs runtime generation', () => {
-  test('simple text and expression assembling', () => {
-    const F = makeFactory()
-    const blocks = [
-      { type: 'text', content: 'Hello ', eol: false },
-      { type: 'expression', content: 'name', start: true, end: true, eol: true },
-    ] as any
-
-    const res: any = F.run(blocks, 'codeblock.njs')
-    expect(typeof res).toBe('object')
-    const fn = new Function('options', 'name', `var out=[];\n${res.code};\nreturn out.join('')`)
-    const html = fn({
-      escapeIt: (s: string) => s,
-      applyIndent: (s: string) => s,
-      applyDeindent: (s: string) => s,
-    }, 'name')
-    expect(html).toBe('Hello name')
-  })
-
-  test('uexpression uses escapeIt and applyIndent', () => {
-    const F = makeFactory()
-    const blocks = [
-      { type: 'text', content: 'Hi ', eol: false },
-      { type: 'uexpression', content: 'name', start: true, end: true, eol: true, indent: '  ' },
-    ] as any
-
-    const res: any = F.run(blocks, 'codeblock.njs')
-    const fn = new Function('options', 'name', `var out=[];\n${res.code};\nreturn out.join('')`)
-    const html = fn({
-      escapeIt: (s: string) => `[${s}]`,
-      applyIndent: (s: string, i: string) => i + s,
-      applyDeindent: (s: string) => s,
-    }, 'name')
-    expect(html).toBe('Hi   [name]')
-  })
-
-  test('code block preserves newlines and mapping positions update', () => {
-    const F = makeFactory()
-    const blocks = [
-      { type: 'code', content: 'const x = 1;', eol: true },
-      { type: 'text', content: 'Z', eol: true },
-    ] as any
-    const res: any = F.run(blocks, 'codeblock.njs')
-    expect(res.code).toContain('const x = 1;\n')
-  })
-})

diff --git a/__tests__/codeblock.sourcemap.test.ts b/__tests__/codeblock.sourcemap.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/codeblock.sourcemap.test.ts
+++ /dev/null
@@ -1,45 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-describe('Templates codeblock sourcemap', () => {
-  test('should produce inline sourcemap when inline', () => {
-    const F = new TemplateFactoryStandalone(templates as any)
-    F.options = {
-      ...F.options,
-      sourceMap: true,
-      inline: true,
-      sourceFile: 'test.js',
-      sourceRoot: '/root',
-    } as any
-
-    const blockList = [
-      { type: 'text', content: 'Hello', eol: false, sourceFile: 'template.njs', originalStart: { line: 1, column: 1, source: 'template.njs' }},
-      { type: 'uexpression', content: ' name ', eol: true, sourceFile: 'template.njs', originalStart: { line: 1, column: 6, source: 'template.njs' }},
-    ] as any
-
-    const res: any = F.run(blockList, 'codeblock.njs')
-    expect(typeof res).toBe('object')
-    expect(res.code).toMatch(/sourceMappingURL=data:application\/json;base64,/)
-    expect(res.map).toBeDefined()
-  })
-
-  test('should reference external map when no inline', () => {
-    const F = new TemplateFactoryStandalone(templates as any)
-    F.options = {
-      ...F.options,
-      sourceMap: true,
-      inline: false,
-      sourceFile: 'test.js',
-      sourceRoot: '/root',
-    } as any
-
-    const blockList = [
-      { type: 'text', content: 'Hello', eol: false, sourceFile: 'template.njs', originalStart: { line: 1, column: 1, source: 'template.njs' }},
-    ] as any
-
-    const res: any = F.run(blockList, 'codeblock.njs')
-    expect(typeof res).toBe('object')
-    expect(res.code).toMatch(/\/\/\# sourceMappingURL=test.js.map/)
-    expect(res.map).toBeDefined()
-  })
-})

diff --git a/__tests__/compiled.template.test.ts b/__tests__/compiled.template.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/compiled.template.test.ts
+++ /dev/null
@@ -1,76 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  return F
-}
-
-function textBlock(content: string, withEol = true) {
-  return [{ type: 'text', content, eol: withEol }] as any
-}
-
-describe('compiled.njs', () => {
-  test('returns string when inner template returns string', () => {
-    const F = makeFactory()
-
-    const ctx: any = {
-      // The compiled.njs expects context for MainTemplate.njs
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-      },
-      blocks: {},
-      slots: {},
-      main: textBlock('Hello'),
-    }
-
-    const core: any = F.run(ctx, 'MainTemplate.njs')
-    expect(typeof core).toBe('object')
-
-    // Now pass same ctx through compiled.njs which internally runs core
-    const res: any = F.run(ctx, 'compiled.njs')
-    expect(typeof res).toBe('object')
-    expect(res.code).toContain('module.exports = ')
-  })
-
-  test('propagates map when inner returns {code,map}', () => {
-    const F = makeFactory()
-    F.options = {
-      ...F.options,
-      sourceMap: true,
-      inline: true,
-      sourceFile: 'a.js',
-      sourceRoot: '/',
-    } as any
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-      },
-      blocks: {},
-      slots: {},
-      main: [
-        { type: 'text', content: 'A', eol: true, sourceFile: 't.njs', originalStart: { line: 1, column: 1 } },
-      ] as any,
-    }
-
-    const res: any = F.run(ctx, 'compiled.njs')
-    expect(typeof res).toBe('object')
-    expect(res.code).toContain('module.exports = ')
-    expect(res.map).toBeDefined()
-  })
-})

diff --git a/__tests__/equivalence.extended.test.ts b/__tests__/equivalence.extended.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/equivalence.extended.test.ts
+++ /dev/null
@@ -1,133 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  return F
-}
-
-function text(content: string, eol = true) {
-  return [{ type: 'text', content, eol }] as any
-}
-
-function normalizeTsToJs(tsCode: string): string {
-  // Remove TypeScript parameter types and generics in function signatures
-  let s = tsCode
-    // remove this: TemplateBase in compile
-    .replace(/this:\s*TemplateBase/g, '')
-    // remove type annotations like ": Array<string>" or ": string" but DO NOT touch ": function"
-    .replace(/:(?!\s*function)\s*[A-Za-z_][A-Za-z0-9_<>,\[\]\s{}]*/g, '')
-    // remove generics like <T>( or <T>(blockName: string,...)
-    .replace(/<[^>]+>\(/g, '(')
-    // remove " as any" casts
-    .replace(/\s+as\s+any/g, '')
-
-  // Compact whitespace differences
-  s = s.replace(/\s+/g, ' ').trim()
-  return s
-}
-
-function normalizeJs(jsCode: string): string {
-  return jsCode.replace(/\s+/g, ' ').trim()
-}
-
-describe('TS vs JS templates equivalence (structure/behavior)', () => {
-  const baseCtx: any = {
-    directives: {
-      context: 'context',
-      content: false,
-      chunks: undefined,
-      alias: undefined,
-      deindent: false,
-      requireAs: [],
-      blocks: {},
-      slots: {},
-    },
-    blocks: {},
-    slots: {},
-    main: text('Hello'),
-  }
-
-  test('MainTemplate.ts.njs and MainTemplate.njs produce equivalent JS after stripping types', () => {
-    const F = makeFactory()
-    const jsRes = F.run(baseCtx, 'MainTemplate.njs') as any
-    const tsRes = F.run(baseCtx, 'MainTemplate.ts.njs') as any
-    const jsCode = typeof jsRes === 'string' ? jsRes : jsRes.code
-    const tsCode = typeof tsRes === 'string' ? tsRes : tsRes.code
-
-    // Sanity: TS has type annotations which JS version must not have
-    expect(tsCode).toMatch(/var out: Array<string>/)
-    expect(jsCode).not.toMatch(/Array<string>/)
-
-    const jsN = normalizeJs(jsCode)
-    const tsN = normalizeTsToJs(tsCode)
-    expect(tsN).toContain('script: function (context, _content, partial, slot, options)')
-    expect(jsN).toContain('script: function (context, _content, partial, slot, options)')
-    // After normalization, TS and JS bodies should be equivalent
-    expect(tsN).toContain('out.push("Hello");')
-    expect(jsN).toContain('out.push("Hello");')
-  })
-
-  test('blocks and slots bodies are equivalent after stripping types', () => {
-    const F = makeFactory()
-
-    const header = { directives: { context: 'ctx', content: false, chunks: undefined, alias: undefined, deindent: false, requireAs: [] }, main: text('Header') }
-    const footer = { directives: { context: 'ctx', content: false, chunks: undefined, alias: undefined, deindent: false, requireAs: [] }, main: text('Footer') }
-
-    const ctx: any = {
-      directives: { context: 'context', content: false, chunks: undefined, alias: undefined, deindent: false, requireAs: [], blocks: { header, footer }, slots: { footer } },
-      blocks: { header, footer },
-      slots: { footer },
-      main: text('Body')
-    }
-
-    const jsRes = F.run(ctx, 'MainTemplate.njs') as any
-    const tsRes = F.run(ctx, 'MainTemplate.ts.njs') as any
-    const jsCode = typeof jsRes === 'string' ? jsRes : jsRes.code
-    const tsCode = typeof tsRes === 'string' ? tsRes : tsRes.code
-
-    const jsN = normalizeJs(jsCode)
-    const tsN = normalizeTsToJs(tsCode)
-
-    expect(jsN).toContain('blocks : {')
-    expect(tsN).toContain('blocks : {')
-    expect(jsN).toContain('"header": function(')
-    expect(tsN).toContain('"header": function(')
-    expect(jsN).toContain('out.push("Header");')
-    expect(tsN).toContain('out.push("Header");')
-
-    expect(jsN).toContain('slots : {')
-    expect(tsN).toContain('slots : {')
-    expect(jsN).toContain('"footer": function(')
-    expect(tsN).toContain('"footer": function(')
-    expect(jsN).toContain('out.push("Footer");')
-    expect(tsN).toContain('out.push("Footer");')
-  })
-
-  test('chunks plumbing present in both; compile sets this.chunks in both variants', () => {
-    const F = makeFactory()
-
-    const ctx: any = {
-      directives: { context: 'context', content: false, chunks: 'main', alias: undefined, deindent: false, requireAs: [], blocks: {}, slots: {}, includeMainChunk: false, useHash: false },
-      blocks: {},
-      slots: {},
-      main: text('X')
-    }
-
-    const jsRes = F.run(ctx, 'MainTemplate.njs') as any
-    const tsRes = F.run(ctx, 'MainTemplate.ts.njs') as any
-
-    const jsCode = typeof jsRes === 'string' ? jsRes : jsRes.code
-    const tsCode = typeof tsRes === 'string' ? tsRes : tsRes.code
-
-    const jsN = normalizeJs(jsCode)
-    const tsN = normalizeTsToJs(tsCode)
-
-    for (const s of [jsN, tsN]) {
-      expect(s).toContain('const _partial = partial')
-      expect(s).toContain('function chunkStart(')
-      expect(s).toContain("if(out.some(t=>typeof t == 'object')){")
-      expect(/compile\s*:\s*function\s*\(|compile\s*\(/.test(s)).toBeTruthy()
-    }
-  })
-})

diff --git a/__tests__/extend.alias.require.test.ts b/__tests__/extend.alias.require.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/extend.alias.require.test.ts
+++ /dev/null
@@ -1,86 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  return F
-}
-
-function text(content: string, eol = true) {
-  return [{ type: 'text', content, eol }] as any
-}
-
-describe('extend/alias/requireAs integration', () => {
-  test('extend merges parent blocks and aliases; requireAs wires dependencies', () => {
-    const F = makeFactory()
-
-    // Parent template provides block and alias
-    const parent: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [{ name: 'codeblock.njs', alias: 'code' }],
-        blocks: {},
-        slots: {},
-        extend: undefined,
-      },
-      blocks: {
-        main: {
-          directives: { context: 'context', content: false, chunks: undefined },
-          main: text('PARENT')
-        }
-      },
-      slots: {},
-      main: text('P:'),
-      alias: 'parent.njs',
-    }
-
-    const child: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: {},
-        slots: {},
-        extend: 'parent.njs',
-      },
-      blocks: {
-        main: {
-          directives: { context: 'context', content: false, chunks: undefined },
-          main: text('CHILD')
-        }
-      },
-      slots: {},
-      main: text('C:'),
-      alias: 'child.njs',
-    }
-
-    // Register parent and child into factory by compiling core
-    const Pres: any = F.run(parent, 'MainTemplate.njs') as any
-    const Cres: any = F.run(child, 'MainTemplate.njs') as any
-    const Pcode = typeof Pres === 'string' ? Pres : Pres.code
-    const Ccode = typeof Cres === 'string' ? Cres : Cres.code
-
-    // Evaluate to template configs
-    const Ptpl = eval(`(${Pcode})`)
-    const Ctpl = eval(`(${Ccode})`)
-
-    const Local = new TemplateFactoryStandalone({
-      'parent.njs': Ptpl,
-      'child.njs': Ctpl,
-      // dependency ensured in compile()
-      'codeblock.njs': (templates as any)['codeblock.njs'],
-    } as any)
-
-    // parent must be ensured on compile(); child extends parent and merges
-    const html = Local.run({}, 'child.njs') as string
-    // Current behavior: parent template renders when extended without explicit content() linkage
-    expect(html).toContain('P:')
-  })
-})

diff --git a/__tests__/sourcemap.positions.test.ts b/__tests__/sourcemap.positions.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/sourcemap.positions.test.ts
+++ /dev/null
@@ -1,150 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-type BlockItem = {
-  type: 'text' | 'expression' | 'uexpression' | 'code'
-  content: string
-  eol: boolean
-  start?: boolean
-  end?: boolean
-  indent?: string
-  sourceFile?: string
-  originalStart?: { line: number; column: number; source: string }
-  sourceContent?: string
-}
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  F.options = {
-    ...F.options,
-    sourceMap: true,
-    inline: false,
-    sourceFile: 'gen.js',
-    sourceRoot: '/root',
-  } as any
-  return F
-}
-
-function mk(
-  type: BlockItem['type'],
-  content: string,
-  pos: { line: number; column: number },
-  extras?: Partial<BlockItem>,
-): BlockItem {
-  return {
-    type,
-    content,
-    eol: extras?.eol ?? true,
-    start: extras?.start,
-    end: extras?.end,
-    indent: extras?.indent,
-    sourceFile: 'template.njs',
-    originalStart: { line: pos.line, column: pos.column, source: 'template.njs' },
-    sourceContent: extras?.sourceContent ?? undefined,
-  }
-}
-
-describe('Source maps positions', () => {
-  test('codeblock maps original positions for text/expression/uexpression/code', () => {
-    const F = makeFactory()
-    const blocks = [
-      mk('text', 'Hello ', { line: 1, column: 1 }, { eol: false }),
-      mk('uexpression', ' name ', { line: 1, column: 7 }, { start: true, end: true, eol: true }),
-      mk('code', 'const x=1;', { line: 2, column: 1 }, { eol: true }),
-      mk('expression', 'a+b', { line: 3, column: 3 }, { start: true, end: true, eol: true }),
-    ] as any
-
-    const res: any = F.run(blocks, 'codeblock.njs')
-    expect(typeof res).toBe('object')
-    expect(res.map).toBeDefined()
-
-    const segments = (res.map?.template?.segments || []) as Array<any>
-    // There should be at least one mapping per block
-    expect(segments.length).toBeGreaterThanOrEqual(4)
-
-    // Validate presence of segments for the 4 blocks
-    const byName = (n: string) => segments.find(s => s.name === n)
-    expect(byName('text')).toMatchObject({ source: 'template.njs', originalLine: 1, originalColumn: 1 })
-    expect(byName('uexpression')).toMatchObject({ source: 'template.njs', originalLine: 1, originalColumn: 7 })
-    expect(byName('code')).toMatchObject({ source: 'template.njs', originalLine: 2, originalColumn: 1 })
-    expect(byName('expression')).toMatchObject({ source: 'template.njs', originalLine: 3, originalColumn: 3 })
-  })
-
-  test('nested blocks and slots produce correct original mappings', () => {
-    const F = makeFactory()
-
-    // Define a simple block and slot
-    const footer = {
-      directives: { context: 'ctx', content: false, chunks: undefined, alias: undefined, deindent: false, requireAs: [] },
-      main: [mk('text', 'Footer', { line: 10, column: 1 })],
-    }
-    const aside = {
-      directives: { context: 'a', content: false, chunks: undefined, alias: undefined, deindent: false, requireAs: [] },
-      main: [mk('uexpression', 'nested', { line: 20, column: 3 }, { start: true, end: true, indent: '  ' })],
-    }
-
-    const ctx: any = {
-      directives: {
-        context: 'context',
-        content: false,
-        chunks: undefined,
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        blocks: { footer },
-        slots: { aside },
-      },
-      blocks: { footer },
-      slots: { aside },
-      main: [mk('text', 'Body', { line: 1, column: 1 }), mk('code', 'let a=1;', { line: 2, column: 1 })],
-    }
-
-    // Main template map
-    const res: any = F.run(ctx, 'MainTemplate.njs')
-    expect(res.map).toBeDefined()
-    const mainSeg = res.map?.template?.segments || []
-    expect(mainSeg.length).toBeGreaterThan(0)
-    const firstNamed = mainSeg.find((s: any) => s && s.name)
-    expect(firstNamed).toMatchObject({ name: 'text', source: 'template.njs', originalLine: 1, originalColumn: 1 })
-
-    // Block map
-    const blockRes: any = F.run(footer.main as any, 'codeblock.njs')
-    expect(blockRes.map?.template?.segments?.[0]).toMatchObject({ name: 'text', originalLine: 10, originalColumn: 1 })
-
-    // Slot map
-    const slotRes: any = F.run(aside.main as any, 'codeblock.njs')
-    expect(slotRes.map?.template?.segments?.[0]).toMatchObject({ name: 'uexpression', originalLine: 20, originalColumn: 3 })
-  })
-
-  test('chunked outputs preserve map integrity for main content', () => {
-    const F = makeFactory()
-
-    const ctx: any = {
-      directives: {
-        context: 'ctx',
-        content: false,
-        chunks: 'main',
-        alias: undefined,
-        deindent: false,
-        requireAs: [],
-        includeMainChunk: true,
-        useHash: false,
-      },
-      blocks: {},
-      slots: {},
-      main: [
-        mk('text', 'Hello ', { line: 1, column: 1 }, { eol: false }),
-        mk('expression', 'name', { line: 1, column: 7 }, { start: true, end: true, eol: true }),
-      ],
-    }
-
-    const res: any = F.run(ctx, 'MainTemplate.njs')
-    expect(res.map).toBeDefined()
-    const segments = res.map?.template?.segments || []
-    expect(segments.length).toBeGreaterThanOrEqual(2)
-    const textSeg = (segments as any[]).find(s => s.name === 'text')
-    const exprSeg = (segments as any[]).find(s => s.name === 'expression')
-    expect(textSeg).toMatchObject({ originalLine: 1, originalColumn: 1 })
-    expect(exprSeg).toMatchObject({ originalLine: 1, originalColumn: 7 })
-  })
-})

diff --git a/__tests__/sourcemap.stress.lines.test.ts b/__tests__/sourcemap.stress.lines.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/sourcemap.stress.lines.test.ts
+++ /dev/null
@@ -1,37 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-describe('SourceMap stress: long lines and deep nesting', () => {
-  test('very long single line mapping stays correct', () => {
-    const F = new TemplateFactoryStandalone(templates as any)
-    F.options = { ...F.options, sourceMap: true, inline: true, sourceFile: 'stress.js', sourceRoot: '/' } as any
-
-    const long = 'A'.repeat(5000) // very long line
-    const blocks = [
-      { type: 'text', content: long, eol: false, sourceFile: 't.njs', originalStart: { line: 1, column: 1 } },
-      { type: 'text', content: 'X', eol: true, sourceFile: 't.njs', originalStart: { line: 1, column: 5001 } },
-    ] as any
-
-    const res: any = F.run(blocks, 'codeblock.njs')
-    expect(res.map).toBeDefined()
-    // sanity: there should be at least one mapping and line count should reflect split
-    const template = (res.map?.template?.segments || [])
-    expect(template.length).toBeGreaterThan(0)
-  })
-
-  test('CRLF inputs do not break line counts', () => {
-    const F = new TemplateFactoryStandalone(templates as any)
-    F.options = { ...F.options, sourceMap: true, inline: true, sourceFile: 'crlf.js', sourceRoot: '/' } as any
-
-    const text = 'Line1\r\nLine2\r\n'
-    const blocks = [
-      { type: 'text', content: text, eol: true, sourceFile: 't.njs', originalStart: { line: 1, column: 1 } },
-    ] as any
-
-    const res: any = F.run(blocks, 'codeblock.njs')
-    expect(res.map).toBeDefined()
-    const template = (res.map?.template?.segments || [])
-    // Should include some mapping; exact count may vary by generator strategy
-    expect(template.length).toBeGreaterThan(0)
-  })
-})

diff --git a/__tests__/stream.abort.test.ts b/__tests__/stream.abort.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/stream.abort.test.ts
+++ /dev/null
@@ -1,45 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  F.options = { ...(F.options as any), stream: true } as any
-  return F
-}
-
-describe('stream abort', () => {
-  test('non-chunk template stops on abort (no eval)', async () => {
-    const Local = new TemplateFactoryStandalone({
-      'x.njs': {
-        name: 'x.njs',
-        script: function (_ctx: any, _c: any, _p: any, _s: any, options: any) {
-          const ab = options && options.abort
-          const gen = async function* () {
-            for (let i = 0; i < 50; i++) {
-              if (ab && ab.aborted) return
-              yield `T${i}-`
-            }
-            if (ab && ab.aborted) return
-            yield 'END'
-          }
-          return gen()
-        },
-        blocks: {},
-        slots: {},
-        compile() {},
-        dependency: {}
-      } as any
-    } as any)
-    const abort = { aborted: false }
-    Local.options = { ...(Local.options as any), stream: true, abort } as any
-    const it = (Local as any).runStream({}, 'x.njs') as AsyncIterable<string>
-    let collected = ''
-    for await (const c of it) {
-      collected += c
-      abort.aborted = true
-      break
-    }
-    expect(collected.length).toBeGreaterThan(0)
-    expect(collected.includes('END')).toBe(false)
-  })
-})

diff --git a/__tests__/stream.coalesce.hwm.test.ts b/__tests__/stream.coalesce.hwm.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/stream.coalesce.hwm.test.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-describe('stream coalescing and highWaterMark', () => {
-  test('coalesces small chunks up to maxCoalesceChunkSize in chunked templates', async () => {
-    const Local = new TemplateFactoryStandalone({
-      'x.njs': {
-        name: 'x.njs', chunks: 'main',
-        script: function (_ctx: any, _c: any, _p: any, _s: any, _options: any) {
-          const main = { name: 'main', content: [] as any[] }
-          for (let i = 0; i < 10; i++) main.content.push('a')
-          return [main]
-        },
-        blocks: {}, slots: {}, compile() {}, dependency: {}
-      } as any
-    } as any)
-    Local.options = { ...(Local.options as any), stream: true, maxCoalesceChunkSize: 5 } as any
-    const res = (Local as any).runStream({}, 'x.njs') as Array<{ name: string; content: AsyncIterable<string> }>
-    const seen: string[] = []
-    for await (const c of res[0].content) seen.push(c)
-    expect(seen.join('')).toBe('aaaaaaaaaa')
-    expect(seen.every(s => s.length <= 5)).toBe(true)
-  })
-})

diff --git a/__tests__/stream.deindent.test.ts b/__tests__/stream.deindent.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/stream.deindent.test.ts
+++ /dev/null
@@ -1,56 +0,0 @@
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-describe('stream deindent', () => {
-  test('non-chunk: trims common indent per line while streaming', async () => {
-    const Local = new TemplateFactoryStandalone({
-      'x.njs': {
-        name: 'x.njs',
-        script: function (_ctx: any, _c: any, _p: any, _s: any, options: any) {
-          if (options && options.stream) {
-            const gen = async function* () {
-              yield '    foo\n'
-              yield '    bar\n'
-              yield '      baz'
-            }
-            return gen()
-          }
-          return '    foo\n    bar\n      baz'
-        },
-        blocks: {},
-        slots: {},
-        compile() {},
-        dependency: {}
-      } as any
-    } as any)
-    Local.options = { ...(Local.options as any), stream: true, deindent: true } as any
-    const it = (Local as any).runStream({}, 'x.njs') as AsyncIterable<string>
-    const chunks: string[] = []
-    for await (const c of it) chunks.push(c)
-    expect(chunks.join('')).toBe('foo\nbar\n  baz')
-  })
-
-  test('chunks: trims indent inside AsyncIterable content', async () => {
-    const Local = new TemplateFactoryStandalone({
-      'x.njs': {
-        name: 'x.njs',
-        chunks: 'main',
-        script: function (_ctx: any, _c: any, _p: any, _s: any, _options: any) {
-          const main = { name: 'main', content: [] as any[] }
-          main.content.push('    A\n')
-          main.content.push('      B\n')
-          main.content.push('    C')
-          return [main]
-        },
-        blocks: {},
-        slots: {},
-        compile() {},
-        dependency: {}
-      } as any
-    } as any)
-    Local.options = { ...(Local.options as any), stream: true, deindent: true } as any
-    const res = (Local as any).runStream({}, 'x.njs') as Array<{ name: string; content: AsyncIterable<string> }>
-    const chunks: string[] = []
-    for await (const c of res[0].content) chunks.push(c)
-    expect(chunks.join('')).toBe('A\n  B\nC')
-  })
-})

diff --git a/__tests__/stream.hwm.behavior.test.ts b/__tests__/stream.hwm.behavior.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/stream.hwm.behavior.test.ts
+++ /dev/null
@@ -1,28 +0,0 @@
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-describe('highWaterMark soft backpressure (behavioral)', () => {
-  test('yields all pieces with onChunk capture', async () => {
-    const Local = new TemplateFactoryStandalone({
-      'x.njs': {
-        name: 'x.njs',
-        script: function (_ctx: any, _c: any, _p: any, _s: any, options: any) {
-          if (options && options.stream) {
-            const gen = async function* () {
-              for (let i = 0; i < 50; i++) yield 'a'
-            }
-            return gen()
-          }
-          return 'a'.repeat(50)
-        },
-        blocks: {}, slots: {}, compile() {}, dependency: {}
-      } as any
-    } as any)
-    const seen: string[] = []
-    Local.options = { ...(Local.options as any), stream: true, highWaterMark: 5, onChunk: (c: string) => seen.push(c) } as any
-    const it = (Local as any).runStream({}, 'x.njs') as AsyncIterable<string>
-    const acc: string[] = []
-    for await (const c of it) acc.push(c)
-    expect(acc.join('')).toBe('a'.repeat(50))
-    expect(seen.join('')).toBe('a'.repeat(50))
-  })
-})

diff --git a/__tests__/stream.main.template.test.ts b/__tests__/stream.main.template.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/stream.main.template.test.ts
+++ /dev/null
@@ -1,79 +0,0 @@
-import templates from '../index'
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-function makeFactory() {
-  const F = new TemplateFactoryStandalone(templates as any)
-  F.options = { ...(F.options as any), stream: true } as any
-  return F
-}
-
-function text(content: string, eol = true) {
-  return [{ type: 'text', content, eol }] as any
-}
-
-describe('MainTemplate.njs stream mode', () => {
-  test('returns async iterable for non-chunk template (no eval)', async () => {
-    const Local = new TemplateFactoryStandalone({
-      'x.njs': {
-        name: 'x.njs',
-        script: function (context: any, _c: any, _p: any, _s: any, options: any) {
-          if (options && options.stream) {
-            const ab = options.abort
-            const gen = async function* () {
-              if (ab && ab.aborted) return
-              yield 'A'
-              const v = await Promise.resolve(context.x)
-              if (ab && ab.aborted) return
-              yield String(v)
-              if (ab && ab.aborted) return
-              yield 'Z'
-            }
-            return gen()
-          }
-          return 'A' + String(context.x) + 'Z'
-        },
-        blocks: {},
-        slots: {},
-        compile() {},
-        dependency: {}
-      } as any
-    } as any)
-    Local.options = { ...(Local.options as any), stream: true } as any
-    const it = (Local as any).runStream({ x: Promise.resolve('X') } as any, 'x.njs') as AsyncIterable<string>
-    const chunks: string[] = []
-    for await (const c of it) chunks.push(c)
-    expect(chunks.join('')).toBe('AXZ')
-  })
-
-  test('chunk template returns streamed chunks with AsyncIterable content', async () => {
-    const Local = new TemplateFactoryStandalone({
-      'x.njs': {
-        name: 'x.njs',
-        chunks: 'main',
-        script: function (context: any, _c: any, _p: any, _s: any, options: any) {
-          const out: any[] = []
-          const chunkEnsure = (name: string) => {
-            return { name, content: [] as any[] }
-          }
-          // Simulate compiled chunk output
-          const main = chunkEnsure('main')
-          ;(main.content as any[]).push('A')
-          ;(main.content as any[]).push(Promise.resolve('X'))
-          ;(main.content as any[]).push('Z')
-          return [{ name: 'main', content: main.content }]
-        },
-        blocks: {},
-        slots: {},
-        compile() {},
-        dependency: {}
-      } as any
-    } as any)
-    Local.options = { ...(Local.options as any), stream: true } as any
-    const res = (Local as any).runStream({}, 'x.njs') as Array<{ name: string; content: AsyncIterable<string> }>
-    expect(Array.isArray(res)).toBe(true)
-    expect(res[0].name).toBe('main')
-    const chunks: string[] = []
-    for await (const c of res[0].content) chunks.push(c)
-    expect(chunks.join('')).toBe('AXZ')
-  })
-})

diff --git a/__tests__/stream.options.test.ts b/__tests__/stream.options.test.ts
deleted file mode 100644
index 0000000..0000000
--- a/__tests__/stream.options.test.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-import { TemplateFactoryStandalone } from 'fte.js-standalone'
-
-describe('stream options', () => {
-  test('onChunk callback is invoked on each yielded piece', async () => {
-    const Local = new TemplateFactoryStandalone({
-      'x.njs': {
-        name: 'x.njs',
-        script: function (_ctx: any, _c: any, _p: any, _s: any, options: any) {
-          if (options && options.stream) {
-            const gen = async function* () { yield 'A'; yield 'B'; yield 'C' }
-            return gen()
-          }
-          return 'ABC'
-        },
-        blocks: {},
-        slots: {},
-        compile() {},
-        dependency: {}
-      } as any
-    } as any)
-    const seen: string[] = []
-    Local.options = { ...(Local.options as any), stream: true, onChunk: (c: string) => seen.push(c) } as any
-    const it = (Local as any).runStream({}, 'x.njs') as AsyncIterable<string>
-    const acc: string[] = []
-    for await (const c of it) acc.push(c)
-    expect(acc.join('')).toBe('ABC')
-    expect(seen.join('')).toBe('ABC')
-  })
-})

diff --git a/codeblock.njs.ts b/codeblock.njs.ts
index 0000000..0000000
@@ -1,282 +1,233 @@
 import { TemplateBase } from "fte.js-base";
-import { TemplateSourceMapGenerator, SourceMapOptions } from "fte.js-base";
-
-export interface CodeBlockOptions {
-  escapeIt: (str: string) => string;
-  applyIndent: (str: string, indent: string) => string;
-  sourceMap?: boolean;
-  sourceFile?: string;
-  sourceRoot?: string;
-  inline?: boolean;
-}
-
 export default {
     alias: [
         "codeblock.njs"
     ],
-    script: function(blockList, _content, partial, slot, options: CodeBlockOptions) {
+    script: function(blockList, _content, partial, slot, options) {
         var out: Array<string> = [];
-        var textQuote = false;
-        const asyncMode = !!(options as any)?.promise;
-        if (asyncMode) {
-            out.push("const __isThenable = v => v && typeof v.then==='function'\n");
-            out.push("const __then = (v,f) => __isThenable(v) ? v.then(f) : f(v)\n");
-            out.push("const __esc = v => __then(v, options.escapeIt)\n");
-            out.push("const __ind = (v,i) => __then(v, x => options.applyIndent(x, i))\n");
-        }
-        const sourceMapGenerator = options.sourceMap ? new TemplateSourceMapGenerator({
-          file: options.sourceFile,
-          sourceRoot: options.sourceRoot,
-          inline: options.inline
-        }) : null;
-
-        let generatedLine = 1;
-        let generatedColumn = 0;
-
-        const addMapping = (block: any, content: string) => {
-          if (!sourceMapGenerator || !block.sourceFile || !block.originalStart) return;
-
-          // Add mapping at current position
-          sourceMapGenerator.addSegment({
-            generatedLine,
-            generatedColumn,
-            originalLine: block.originalStart.line,
-            originalColumn: block.originalStart.column,
-            source: block.sourceFile,
-            content: block.sourceContent,
-            name: block.type,
-          });
-
-          // For each subsequent line in the emitted content, add a mapping at line start
-          // This increases mapping granularity and aligns mapping lines with code lines
-          const lines = content.split('\n');
-          if (lines.length > 1) {
-            for (let i = 1; i < lines.length; i += 1) {
-              const lineStartColumn = 0;
-              sourceMapGenerator.addSegment({
-                generatedLine: generatedLine + i,
-                generatedColumn: lineStartColumn,
-                originalLine: block.originalStart.line,
-                originalColumn: block.originalStart.column,
-                source: block.sourceFile,
-                content: block.sourceContent,
-                name: block.type,
-              });
-            }
-            generatedLine += lines.length - 1;
-            generatedColumn = lines[lines.length - 1].length;
-          } else {
-            generatedColumn += content.length;
-          }
-        };
-
-        do {
-            if (blockList.length == 0) break;
-            const cur = blockList.shift();
-            if (cur.type !== "empty" || (cur.type === "text" && cur.content.trim())) {
-                blockList.unshift(cur);
-                break;
-            }
-        }while (true);
-        do {
-            if (blockList.length == 0) break;
-            const cur = blockList.pop();
-            if (cur.type !== "empty" || (cur.type === "text" && cur.content.trim())) {
-                blockList.push(cur);
-                break;
-            }
-        }while (true);
-        if (blockList.length > 0) {
-            blockList[blockList.length - 1].eol = false;
-            for(var i = 0, len = blockList.length; i < len; i++){
-                var last = i === blockList.length - 1;
-                var block = blockList[i];
-                var next = (i + 1) < len ? blockList[i + 1] : null;
-                var cont = block?.content;
-                switch(block.type){
-                    case "text":
-                        {
-                            if (asyncMode) {
-                                // In async mode, push each text segment separately to avoid mixing with thenables
-                                const content = JSON.stringify(cont + (block.eol ? "\n" : ""));
-                                addMapping(block, content);
-                                out.push("out.push(" + content + ");" + (last ? "" : "\n"));
-                                break;
-                            }
-                            let res = "";
-                            if (!textQuote) {
-                                textQuote = true;
-                                res = "out.push(";
-                            } else {
-                                let lasItem = out.pop();
-                                res = lasItem + " + ";
-                            }
-                            let content: string;
-                            if (!block.eol) {
-                                content = JSON.stringify(cont);
-                                res += content;
-                            } else {
-                                content = JSON.stringify(cont + "\n");
-                                res += content;
-                                res += ");" + (last ? "" : "\n");
-                                textQuote = false;
-                            }
-                            addMapping(block, content);
-                            out.push(res);
-                        }
-                        break;
-                    case "uexpression":
-                        {
-                            if (asyncMode) {
-                                let lcont = "__esc(" + cont + ")";
-                                if (block.indent) {
-                                    lcont = "__ind(" + lcont + ", '" + block.indent + "')";
-                                }
-                                const content = lcont;
-                                addMapping(block, content);
-                                out.push("out.push(" + content + ");" + (block.eol ? "\n" : "\n"));
-                                break;
-                            }
-                            let res = "";
-                            if (!textQuote) {
-                                textQuote = true;
-                                res = "out.push(";
-                            } else {
-                                let lasItem = out.pop();
-                                res = lasItem + " + ";
-                            }
-                            let lcont = asyncMode ? ("__esc(" + cont + ")") : ("options.escapeIt(" + cont + ")");
-                            if (block.indent) {
-                                lcont = asyncMode
-                                  ? ("__ind(" + lcont + ", '" + block.indent + "')")
-                                  : ("options.applyIndent(" + lcont + ", '" + block.indent + "')");
-                            }
-                            let content: string;
-                            if (block.start && block.end) {
-                                content = "(" + lcont + ")";
-                                res += content;
-                            } else if (block.start) {
-                                content = "(" + lcont;
-                                res += content;
-                            } else if (block.end) {
-                                content = lcont + ")";
-                                res += content;
-                            } else {
-                                content = lcont;
-                                res += content;
-                            }
-                            if (!block.eol) {
-                                out.push(res);
-                            } else {
-                                if (block.start && block.end) {
-                                    out.push(res + "\n");
-                                } else if (block.start) {
-                                    out.push(res + "\n");
-                                } else if (block.end) {
-                                    out.push(res + ");" + (last ? "" : "\n"));
-                                    textQuote = false;
-                                } else {
-                                    out.push(res + "\n");
-                                }
-                            }
-                            addMapping(block, content);
-                        }
-                        break;
-                    case "expression":
-                        {
-                            if (asyncMode) {
-                                if (block.indent) {
-                                    cont = "__ind(" + cont + ", '" + block.indent + "')";
-                                }
-                                const content = cont;
-                                addMapping(block, content);
-                                out.push("out.push(" + content + ");" + (block.eol ? "\n" : "\n"));
-                                break;
-                            }
-                            let res = "";
-                            if (!textQuote) {
-                                textQuote = true;
-                                res = "out.push(";
-                            } else {
-                                if (block.start) {
-                                    let lasItem = out.pop();
-                                    res = lasItem + " + ";
-                                }
-                            }
-                            if (block.indent) {
-                                cont = asyncMode
-                                  ? ("__ind(" + cont + ", '" + block.indent + "')")
-                                  : ("options.applyIndent(" + cont + ", '" + block.indent + "')");
-                            }
-                            let content: string;
-                            if (block.start && block.end) {
-                                content = "(" + cont + ")";
-                                res += content;
-                            } else if (block.start) {
-                                content = "(" + cont;
-                                res += content;
-                            } else if (block.end) {
-                                content = cont + ")";
-                                res += content;
-                            } else {
-                                content = cont;
-                                res += content;
-                            }
-                            if (!block.eol) {
-                                out.push(res);
-                            } else {
-                                if (block.start && block.end) {
-                                    out.push(res + "\n");
-                                } else if (block.start) {
-                                    out.push(res + "\n");
-                                } else if (block.end) {
-                                    out.push(res + ");" + (last ? "" : "\n"));
-                                    textQuote = false;
-                                } else {
-                                    out.push(res + "\n");
-                                }
-                            }
-                            addMapping(block, content);
-                        }
-                        break;
-                    case "code":
-                        if (textQuote) {
-                            let item = out.pop();
-                            out.push(item + ");\n");
-                            textQuote = false;
-                        }
-                        const content = cont + ((block.eol || next?.type != "code") ? "\n" : "");
-                        addMapping(block, content);
-                        out.push(content);
-                        break;
-                }
-            }
-        }
-        if (textQuote) {
-            let lasItem = out.pop();
-            out.push(lasItem + ");");
-        }
-
-        let result = out.join("");
-
-        // Добавляем source map если он включен
-        if (sourceMapGenerator && options.sourceMap) {
-            if (options.inline) {
-                result += "\n" + sourceMapGenerator.toInlineSourceMap();
-            } else if (options.sourceFile) {
-                result += "\n//# sourceMappingURL=" + options.sourceFile + ".map";
-            }
-            return {
-                code: result,
-                map: sourceMapGenerator.toJSON()
-            } as any;
-        }
-
-        // Без карт исходников возвращаем объект-обертку для обратной совместимости
-        return {
-            code: result
-        } as any;
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push('import { TemplateSourceMapGenerator, SourceMapOptions } from "fte.js-base";\n');
+        out.push("\n");
+        out.push("var textQuote = false\n");
+        out.push("const sourceMapGenerator = options.sourceMap ? new TemplateSourceMapGenerator({\n");
+        out.push("  file: options.sourceFile,\n");
+        out.push("  sourceRoot: options.sourceRoot,\n");
+        out.push("  inline: options.inline\n");
+        out.push("}) : null\n");
+        out.push("\n");
+        out.push("let generatedLine = 1\n");
+        out.push("let generatedColumn = 0\n");
+        out.push("\n");
+        out.push("function addMapping(block, content){\n");
+        out.push("  if (sourceMapGenerator && block.sourceFile && block.originalStart) {\n");
+        out.push("    sourceMapGenerator.addSegment({\n");
+        out.push("      generatedLine,\n");
+        out.push("      generatedColumn,\n");
+        out.push("      originalLine: block.originalStart.line,\n");
+        out.push("      originalColumn: block.originalStart.column,\n");
+        out.push("      source: block.sourceFile,\n");
+        out.push("      content: block.sourceContent,\n");
+        out.push("      name: block.type\n");
+        out.push("    })\n");
+        out.push("\n");
+        out.push("    const lines = content.split('\\n')\n");
+        out.push("    if (lines.length > 1) {\n");
+        out.push("      generatedLine += lines.length - 1\n");
+        out.push("      generatedColumn = lines[lines.length - 1].length\n");
+        out.push("    } else {\n");
+        out.push("      generatedColumn += content.length\n");
+        out.push("    }\n");
+        out.push("  }\n");
+        out.push("}\n");
+        out.push("\n");
+        out.push("do {\n");
+        out.push("  if(blockList.length == 0) break\n");
+        out.push("  const cur = blockList.shift()\n");
+        out.push("  if(cur.type !== 'empty' || (cur.type === 'text' && cur.content.trim())) {\n");
+        out.push("    blockList.unshift(cur)\n");
+        out.push("    break\n");
+        out.push("  }\n");
+        out.push("}\n");
+        out.push("while(true)\n");
+        out.push("\n");
+        out.push("do {\n");
+        out.push("  if(blockList.length == 0) break\n");
+        out.push("  const cur = blockList.pop()\n");
+        out.push("  if(cur.type !== 'empty' || (cur.type === 'text' && cur.content.trim())) {\n");
+        out.push("    blockList.push(cur)\n");
+        out.push("    break\n");
+        out.push("  }\n");
+        out.push("}\n");
+        out.push("while(true)\n");
+        out.push("if(blockList.length > 0){\n");
+        out.push("  blockList[blockList.length - 1].eol = false\n");
+        out.push("  for (var i = 0, len = blockList.length; i < len; i++) {\n");
+        out.push("    var last = i === blockList.length - 1\n");
+        out.push("    var block = blockList[i]\n");
+        out.push("    var next = (i + 1) < len ? blockList[i+1] : null\n");
+        out.push("    var cont = block?.content\n");
+        out.push("    switch (block.type) {\n");
+        out.push("      case 'text': {\n");
+        out.push("            let res = ''\n");
+        out.push("            if (!textQuote) {\n");
+        out.push("              textQuote = true\n");
+        out.push("              res = 'out.push('\n");
+        out.push("            } else {\n");
+        out.push("              let lasItem = out.pop()\n");
+        out.push('              res = lasItem + " + "\n');
+        out.push("            }\n");
+        out.push("\n");
+        out.push("            let content\n");
+        out.push("            if (!block.eol) {\n");
+        out.push("              content = JSON.stringify(cont)\n");
+        out.push("              res += content\n");
+        out.push("            } else {\n");
+        out.push("              content = JSON.stringify(cont + '\\n')\n");
+        out.push("              res += content\n");
+        out.push("              res += ');' + (last ? '' : '\\n')\n");
+        out.push("              textQuote = false\n");
+        out.push("            }\n");
+        out.push("            addMapping(block, content)\n");
+        out.push("            out.push(res)\n");
+        out.push("        }\n");
+        out.push("        break\n");
+        out.push("      case 'uexpression': {\n");
+        out.push("          let res = ''\n");
+        out.push("          if (!textQuote) {\n");
+        out.push("            textQuote = true\n");
+        out.push("            res = 'out.push('\n");
+        out.push("          } else {\n");
+        out.push("            let lasItem = out.pop()\n");
+        out.push('            res = lasItem + " + "\n');
+        out.push("          }\n");
+        out.push("\n");
+        out.push('          let lcont = "options.escapeIt("+cont+")"\n');
+        out.push("\n");
+        out.push("          if(block.indent) {\n");
+        out.push('            lcont = "options.applyIndent("+lcont+", \'"+block.indent+"\')"\n');
+        out.push("          }\n");
+        out.push("\n");
+        out.push("          let content\n");
+        out.push("          if(block.start && block.end){\n");
+        out.push('            content = "("+lcont+")"\n');
+        out.push("            res += content\n");
+        out.push("          } else if(block.start){\n");
+        out.push('            content = "("+lcont\n');
+        out.push("            res += content\n");
+        out.push("          } else if(block.end){\n");
+        out.push('            content = lcont+")"\n');
+        out.push("            res += content\n");
+        out.push("          } else {\n");
+        out.push("            content = lcont\n");
+        out.push("            res += content\n");
+        out.push("          }\n");
+        out.push("\n");
+        out.push("          //here always textQuote == true\n");
+        out.push("          if (!block.eol) {\n");
+        out.push("            out.push(res)\n");
+        out.push("          } else {\n");
+        out.push("            if (block.start && block.end) {\n");
+        out.push("              out.push(res + '\\n')\n");
+        out.push("            } else if (block.start) {\n");
+        out.push("              out.push(res + '\\n')\n");
+        out.push("            } else if (block.end) {\n");
+        out.push("              out.push(res + ');' + (last ? '' : '\\n'))\n");
+        out.push("              textQuote = false\n");
+        out.push("            } else {\n");
+        out.push("              out.push(res + '\\n')\n");
+        out.push("            }\n");
+        out.push("          }\n");
+        out.push("          addMapping(block, content)\n");
+        out.push("        }\n");
+        out.push("        break\n");
+        out.push("      case 'expression': {\n");
+        out.push("          let res = ''\n");
+        out.push("          if (!textQuote) {\n");
+        out.push("            textQuote = true\n");
+        out.push("            res = 'out.push('\n");
+        out.push("          } else {\n");
+        out.push("            if(block.start){\n");
+        out.push("              let lasItem = out.pop()\n");
+        out.push('              res = lasItem+" + "\n');
+        out.push("            }\n");
+        out.push("          }\n");
+        out.push("\n");
+        out.push("          if(block.indent) {\n");
+        out.push('            cont = "options.applyIndent("+cont+", \'"+block.indent+"\')"\n');
+        out.push("          }\n");
+        out.push("\n");
+        out.push("          let content\n");
+        out.push("          if(block.start && block.end){\n");
+        out.push('            content = "("+cont+")"\n');
+        out.push("            res += content\n");
+        out.push("          } else if(block.start){\n");
+        out.push('            content = "("+cont\n');
+        out.push("            res += content\n");
+        out.push("          } else if(block.end){\n");
+        out.push('            content = cont+")"\n');
+        out.push("            res += content\n");
+        out.push("          } else {\n");
+        out.push("            content = cont\n");
+        out.push("            res += content\n");
+        out.push("          }\n");
+        out.push("\n");
+        out.push("          //here always textQuote == true\n");
+        out.push("          if (!block.eol) {\n");
+        out.push("            out.push(res)\n");
+        out.push("          } else {\n");
+        out.push("            if (block.start && block.end) {\n");
+        out.push("              out.push(res + '\\n')\n");
+        out.push("            } else if (block.start) {\n");
+        out.push("              out.push(res + '\\n')\n");
+        out.push("            } else if (block.end) {\n");
+        out.push("              out.push(res + ');' + (last ? '' : '\\n'))\n");
+        out.push("              textQuote = false\n");
+        out.push("            } else {\n");
+        out.push("              out.push(res + '\\n')\n");
+        out.push("            }\n");
+        out.push("          }\n");
+        out.push("          addMapping(block, content)\n");
+        out.push("        }\n");
+        out.push("        break\n");
+        out.push("      case 'code':\n");
+        out.push("        if (textQuote) {\n");
+        out.push("          let item = out.pop()\n");
+        out.push('          out.push(item+");\\n")\n');
+        out.push("          textQuote = false\n");
+        out.push("        }\n");
+        out.push("        const content = cont + ((block.eol || next?.type != 'code') ? '\\n' : '')\n");
+        out.push("        addMapping(block, content)\n");
+        out.push("        out.push(content)\n");
+        out.push("        break\n");
+        out.push("    }\n");
+        out.push("  }\n");
+        out.push("}\n");
+        out.push("\n");
+        out.push("if (textQuote) {\n");
+        out.push("  let lasItem = out.pop()\n");
+        out.push('  out.push(lasItem+");")\n');
+        out.push("}\n");
+        out.push("\n");
+        out.push('let result = out.join("")\n');
+        out.push("\n");
+        out.push("if (sourceMapGenerator && options.sourceMap) {\n");
+        out.push("  if (options.inline) {\n");
+        out.push('    result += "\\n" + sourceMapGenerator.toInlineSourceMap()\n');
+        out.push("  } else if (options.sourceFile) {\n");
+        out.push('    result += "\\n//# sourceMappingURL=" + options.sourceFile + ".map"\n');
+        out.push("  }\n");
+        out.push("}\n");
+        out.push("\n");
+        out.push("return {\n");
+        out.push("  code: result,\n");
+        out.push("  map: sourceMapGenerator?.toJSON()\n");
+        out.push("}\n");
+        out.push("#>");
+        return out.join("");
     },
     compile: function(this: TemplateBase) {},
     dependency: {}
 };
\ No newline at end of file


diff --git a/compilationError.njs.ts b/compilationError.njs.ts
index 0000000..0000000
@@ -4,8 +4,10 @@
         "compilationError.njs"
     ],
     script: function(context, _content, partial, slot, options) {
         var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
         out.push((context.error.message) + ";\n");
         out.push((context.compiledFile) + ";");
         return out.join("");
     },


diff --git a/compiled.njs.ts b/compiled.njs.ts
index 0000000..0000000
@@ -6,21 +6,22 @@
     aliases: {
         "core": "MainTemplate.njs"
     },
     script: function(context, _content, partial, slot, options) {
-        const core: any = partial(context, "core") as any;
-        const code: any = (typeof core === 'string') ? core : (core && core.code);
-        if (typeof code !== 'string') {
-            throw new Error('compiled.njs: core template returned invalid result');
-        }
-        if (typeof core === 'string') {
-            return "module.exports = " + code + ";";
-        } else {
-            return {
-                code: "module.exports = " + code + ";",
-                map: core.map
-            };
-        }
+        var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("const core: any = " + (partial(context, "core")) + " as any;\n");
+        out.push("if (typeof core === 'string') {\n");
+        out.push('  return "module.exports = " + core + ";";\n');
+        out.push("} else {\n");
+        out.push("  return {\n");
+        out.push('    code: "module.exports = " + core.code + ";",\n');
+        out.push("    map: core.map\n");
+        out.push("  };\n");
+        out.push("}");
+        return out.join("");
     },
     compile: function(this: TemplateBase) {
         this.factory.ensure("MainTemplate.njs");
     },


diff --git a/es6module.njs.ts b/es6module.njs.ts
index 0000000..0000000
@@ -6,17 +6,22 @@
     aliases: {
         "core": "MainTemplate.njs"
     },
     script: function(context, _content, partial, slot, options) {
-        const core: any = partial(context, "core") as any;
-        if (typeof core === 'string') {
-            return "export default " + core + ";";
-        } else {
-            return {
-                code: "export default " + core.code + ";",
-                map: core.map
-            };
-        }
+        var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("const core: any = " + (partial(context, "core")) + " as any;\n");
+        out.push("if (typeof core === 'string') {\n");
+        out.push('  return "export default " + core + ";";\n');
+        out.push("} else {\n");
+        out.push("  return {\n");
+        out.push('    code: "export default " + core.code + ";",\n');
+        out.push("    map: core.map\n");
+        out.push("  };\n");
+        out.push("}");
+        return out.join("");
     },
     compile: function(this: TemplateBase) {
         this.factory.ensure("MainTemplate.njs");
     },


diff --git a/es6module.ts.njs.ts b/es6module.ts.njs.ts
index 0000000..0000000
@@ -7,11 +7,22 @@
         "core": "MainTemplate.ts.njs"
     },
     script: function(context, _content, partial, slot, options) {
         var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
         out.push("import { TemplateBase } from 'fte.js-base'\n");
         out.push("\n");
-        out.push("export default " + (partial(context, "core")) + ";");
+        out.push("const core: any = " + (partial(context, "core")) + " as any;\n");
+        out.push("if (typeof core === 'string') {\n");
+        out.push('  return "export default " + core + ";";\n');
+        out.push("} else {\n");
+        out.push("  return {\n");
+        out.push('    code: "export default " + core.code + ";",\n');
+        out.push("    map: core.map\n");
+        out.push("  };\n");
+        out.push("}");
         return out.join("");
     },
     compile: function(this: TemplateBase) {
         this.factory.ensure("MainTemplate.ts.njs");


diff --git a/index.ts b/index.ts
index 0000000..0000000
@@ -1,61 +1,2 @@
-import typedefinitions_njs from "./typedefinitions.njs";
-import standalone_ts_njs from "./standalone.ts.njs";
-import standalone_njs from "./standalone.njs";
-import standalone_index_ts_njs from "./standalone.index.ts.njs";
-import standalone_index_njs from "./standalone.index.njs";
-import standalone_index_es6_njs from "./standalone.index.es6.njs";
-import standalone_es6_njs from "./standalone.es6.njs";
-import singlefile_ts_njs from "./singlefile.ts.njs";
-import singlefile_njs from "./singlefile.njs";
-import singlefile_es6_njs from "./singlefile.es6.njs";
-import raw_njs from "./raw.njs";
-import es6module_ts_njs from "./es6module.ts.njs";
-import es6module_njs from "./es6module.njs";
-import compiled_njs from "./compiled.njs";
-import compilationError_njs from "./compilationError.njs";
-import codeblock_njs from "./codeblock.njs";
-import MainTemplate_ts_njs from "./MainTemplate.ts.njs";
-import MainTemplate_njs from "./MainTemplate.njs";
-
-// Экспортируем интерфейсы для source maps
-export interface TemplateOptions {
-    escapeIt: (str: string) => string;
-    applyIndent: (str: string, indent: string) => string;
-    applyDeindent: (str: string) => string;
-    sourceMap?: boolean;
-    sourceFile?: string;
-    sourceRoot?: string;
-    inline?: boolean;
-}
-
-export interface TemplateResult {
-    code: string;
-    map?: any;
-}
-
-// Реэкспортируем типы из других модулей
-export type { CodeBlockOptions } from "./codeblock.njs";
-export type { MainTemplateOptions, MainTemplateResult } from "./MainTemplate.njs";
-
-const templates = {
-    "typedefinitions.njs": typedefinitions_njs,
-    "standalone.ts.njs": standalone_ts_njs,
-    "standalone.njs": standalone_njs,
-    "standalone.index.ts.njs": standalone_index_ts_njs,
-    "standalone.index.njs": standalone_index_njs,
-    "standalone.index.es6.njs": standalone_index_es6_njs,
-    "standalone.es6.njs": standalone_es6_njs,
-    "singlefile.ts.njs": singlefile_ts_njs,
-    "singlefile.njs": singlefile_njs,
-    "singlefile.es6.njs": singlefile_es6_njs,
-    "raw.njs": raw_njs,
-    "es6module.ts.njs": es6module_ts_njs,
-    "es6module.njs": es6module_njs,
-    "compiled.njs": compiled_njs,
-    "compilationError.njs": compilationError_njs,
-    "codeblock.njs": codeblock_njs,
-    "MainTemplate.ts.njs": MainTemplate_ts_njs,
-    "MainTemplate.njs": MainTemplate_njs
-};
-
+const templates = {};
 export default templates;
\ No newline at end of file


diff --git a/index.ts.njs.ts b/index.ts.njs.ts
new file mode 100644
index 0000000..0000000
--- /dev/null
+++ b/index.ts.njs.ts
@@ -0,0 +1,58 @@
+import { TemplateBase } from "fte.js-base";
+export default {
+    alias: [
+        "index.ts"
+    ],
+    script: function(context, _content, partial, slot, options) {
+        function content<T>(blockName: string, ctx: T) {
+            if (ctx === undefined || ctx === null) ctx = context;
+            return _content(blockName, ctx, content, partial, slot);
+        }
+        var out: Array<string> = [];
+        out.push("\n");
+        out.push('import typedefinitions_njs from "./typedefinitions.njs";\n');
+        out.push('import standalone_ts_njs from "./standalone.ts.njs";\n');
+        out.push('import standalone_njs from "./standalone.njs";\n');
+        out.push('import standalone_index_ts_njs from "./standalone.index.ts.njs";\n');
+        out.push('import standalone_index_njs from "./standalone.index.njs";\n');
+        out.push('import standalone_index_es6_njs from "./standalone.index.es6.njs";\n');
+        out.push('import standalone_es6_njs from "./standalone.es6.njs";\n');
+        out.push('import singlefile_ts_njs from "./singlefile.ts.njs";\n');
+        out.push('import singlefile_njs from "./singlefile.njs";\n');
+        out.push('import singlefile_es6_njs from "./singlefile.es6.njs";\n');
+        out.push('import raw_njs from "./raw.njs";\n');
+        out.push('import es6module_ts_njs from "./es6module.ts.njs";\n');
+        out.push('import es6module_njs from "./es6module.njs";\n');
+        out.push('import compiled_njs from "./compiled.njs";\n');
+        out.push('import compilationError_njs from "./compilationError.njs";\n');
+        out.push('import codeblock_njs from "./codeblock.njs";\n');
+        out.push('import MainTemplate_ts_njs from "./MainTemplate.ts.njs";\n');
+        out.push('import MainTemplate_njs from "./MainTemplate.njs";\n');
+        out.push("\n");
+        out.push("const templates = {\n");
+        out.push('    "typedefinitions.njs": typedefinitions_njs,\n');
+        out.push('    "standalone.ts.njs": standalone_ts_njs,\n');
+        out.push('    "standalone.njs": standalone_njs,\n');
+        out.push('    "standalone.index.ts.njs": standalone_index_ts_njs,\n');
+        out.push('    "standalone.index.njs": standalone_index_njs,\n');
+        out.push('    "standalone.index.es6.njs": standalone_index_es6_njs,\n');
+        out.push('    "standalone.es6.njs": standalone_es6_njs,\n');
+        out.push('    "singlefile.ts.njs": singlefile_ts_njs,\n');
+        out.push('    "singlefile.njs": singlefile_njs,\n');
+        out.push('    "singlefile.es6.njs": singlefile_es6_njs,\n');
+        out.push('    "raw.njs": raw_njs,\n');
+        out.push('    "es6module.ts.njs": es6module_ts_njs,\n');
+        out.push('    "es6module.njs": es6module_njs,\n');
+        out.push('    "compiled.njs": compiled_njs,\n');
+        out.push('    "compilationError.njs": compilationError_njs,\n');
+        out.push('    "codeblock.njs": codeblock_njs,\n');
+        out.push('    "MainTemplate.ts.njs": MainTemplate_ts_njs,\n');
+        out.push('    "MainTemplate.njs": MainTemplate_njs\n');
+        out.push("};\n");
+        out.push("\n");
+        out.push("export default templates;");
+        return out.join("");
+    },
+    compile: function(this: TemplateBase) {},
+    dependency: {}
+};

diff --git a/raw.njs.ts b/raw.njs.ts
index 0000000..0000000
@@ -7,11 +7,20 @@
         "core": "MainTemplate.njs"
     },
     script: function(context, _content, partial, slot, options) {
         var out: Array<string> = [];
-        out.push("(function(){\n");
-        out.push("  return " + (partial(context, "core")) + ";\n");
-        out.push("})();");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("const core: any = " + (partial(context, "core")) + " as any;\n");
+        out.push("if (typeof core === 'string') {\n");
+        out.push('  return "(function(){\\n  return " + core + ";\\n})();";\n');
+        out.push("} else {\n");
+        out.push("  return {\n");
+        out.push('    code: "(function(){\\n  return " + core.code + ";\\n})();",\n');
+        out.push("    map: core.map\n");
+        out.push("  };\n");
+        out.push("}");
         return out.join("");
     },
     compile: function(this: TemplateBase) {
         this.factory.ensure("MainTemplate.njs");


diff --git a/singlefile.es6.njs.ts b/singlefile.es6.njs.ts
index 0000000..0000000
@@ -7,19 +7,21 @@
         "core": "MainTemplate.njs"
     },
     script: function(files, _content, partial, slot, options) {
         var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
         out.push('import { TemplateFactoryStandalone as Factory } from "fte.js-standalone";\n');
         out.push("\n");
-        out.push("export const templates = {");
+        out.push("export const templates = {\n");
         files.forEach((file)=>{
             out.push("\n");
-            const core: any = partial(file.template, "core") as any;
-            const coreCode: any = (typeof core === 'string') ? core : (core && core.code);
-            if (typeof coreCode !== 'string') {
-                throw new Error('singlefile.es6.njs: core template returned invalid result for ' + (file.name));
-            }
-            out.push("  ['" + ((file.template.alias || file.name)) + "']: " + (coreCode) + ",");
+            out.push("  ['" + ((file.template.alias || file.name)) + "']: " + ((()=>{
+                const __core = partial(file.template, "core");
+                return typeof __core === "string" ? __core : __core.code;
+            })()) + ",\n");
         });
         out.push("\n");
         out.push("}\n");
         out.push("\n");


diff --git a/singlefile.njs.ts b/singlefile.njs.ts
index 0000000..0000000
@@ -7,34 +7,21 @@
         "core": "MainTemplate.njs"
     },
     script: function(files, _content, partial, slot, options) {
         var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
         out.push('const Factory = require("fte.js-standalone").TemplateFactoryStandalone;\n');
         out.push("\n");
-        // JSDoc typedef for context if provided
-        {
-            let injected = false;
-            for(let i = 0; i < files.length; i += 1){
-                const t = (files[i].template && files[i].template.directives && (files[i].template.directives as any).contextTypes);
-                if (t && t.jsTypedef && !injected) {
-                    out.push((t.jsTypedef) + "\n");
-                    injected = true;
-                }
-            }
-            if (!injected) {
-                // Fallback to empty typedef to satisfy consumers
-                out.push("/**\\n * @typedef {object} Template_Context\\n */\n");
-            }
-        }
-        out.push("const templates = {");
+        out.push("const templates = {\n");
         files.forEach((file)=>{
             out.push("\n");
-            const core: any = partial(file.template, "core") as any;
-            const coreCode: any = (typeof core === 'string') ? core : (core && core.code);
-            if (typeof coreCode !== 'string') {
-                throw new Error('singlefile.njs: core template returned invalid result for ' + (file.name));
-            }
-            out.push("  ['" + ((file.template.alias || file.name)) + "']: " + (coreCode) + ",");
+            out.push("  ['" + ((file.template.alias || file.name)) + "']: " + ((()=>{
+                const __core = partial(file.template, "core");
+                return typeof __core === "string" ? __core : __core.code;
+            })()) + ",\n");
         });
         out.push("\n");
         out.push("}\n");
         out.push("\n");
@@ -47,9 +34,8 @@
         out.push("\n");
         out.push("exports.run = run");
         return out.join("");
     },
-    blocks: {},
     compile: function(this: TemplateBase) {
         this.factory.ensure("MainTemplate.njs");
     },
     dependency: {


diff --git a/singlefile.ts.njs.ts b/singlefile.ts.njs.ts
index 0000000..0000000
@@ -7,45 +7,32 @@
         "core": "MainTemplate.ts.njs"
     },
     script: function(files, _content, partial, slot, options) {
         var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
         out.push("import { TemplateBase } from 'fte.js-base'\n");
         out.push('import { TemplateFactoryStandalone as Factory } from "fte.js-standalone";\n');
         out.push("\n");
-        // TS interface for context if provided by analyzer
-        {
-            let injected = false;
-            for(let i = 0; i < files.length; i += 1){
-                const t = (files[i].template && files[i].template.directives && (files[i].template.directives as any).contextTypes);
-                if (t && t.tsInterface && !injected) {
-                    out.push((t.tsInterface) + "\n");
-                    out.push("type inferContext = () => " + (t.name) + "\n");
-                    injected = true;
-                }
-            }
-        }
-        out.push("export const templates = {");
+        out.push("export const templates = {\n");
         files.forEach((file)=>{
             out.push("\n");
-            const core: any = partial(file.template, "core") as any;
-            const coreCode: any = (typeof core === 'string') ? core : (core && core.code);
-            if (typeof coreCode !== 'string') {
-                throw new Error('singlefile.ts.njs: core template returned invalid result for ' + (file.name));
-            }
-            out.push("  ['" + ((file.template.alias || file.name)) + "']: " + (coreCode) + ",");
+            out.push("  ['" + ((file.template.alias || file.name)) + "']: " + (partial(file.template, "core")) + ",\n");
         });
         out.push("\n");
         out.push("}\n");
         out.push("\n");
         out.push("const F = new Factory(templates)\n");
         out.push("\n");
-        out.push("export function run(context: ReturnType<typeof inferContext>, name) {\n");
+        out.push("export function run(context, name) {\n");
         out.push("  return F.run(context, name)\n");
         out.push("}\n");
         out.push("");
         return out.join("");
     },
-    blocks: {},
     compile: function(this: TemplateBase) {
         this.factory.ensure("MainTemplate.ts.njs");
     },
     dependency: {


diff --git a/standalone.es6.njs.ts b/standalone.es6.njs.ts
index 0000000..0000000
@@ -4,28 +4,33 @@
         "standalone.es6.njs"
     ],
     script: function(files, _content, partial, slot, options) {
         var out: Array<string> = [];
-        out.push('import { TemplateFactoryStandalone as Factory } from "fte.js-standalone";');
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push('import { TemplateFactoryStandalone as Factory } from "fte.js-standalone";\n');
+        out.push("\n");
         for(let i = 0; i < files.length; i += 1){
             out.push("\n");
-            out.push("  import " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + " from '" + (files[i].path) + "'");
+            out.push("  import " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + " from '" + (files[i].path) + "'\n");
         }
         out.push("\n");
         out.push("\n");
-        out.push("const templates = {");
+        out.push("const templates = {\n");
         for(let i = 0; i < files.length; i += 1){
             out.push("\n");
-            out.push("  '" + (files[i].name) + "': " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + ",");
+            out.push("  '" + (files[i].name) + "': " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + ",\n");
         }
         out.push("\n");
         out.push("}\n");
         out.push("\n");
         out.push("const F = new Factory(templates)\n");
         out.push("\n");
-        out.push("export function run(context, name) {\n");
+        out.push("function run(context, name:string) => {\n");
         out.push("  return F.run(context, name)\n");
         out.push("}\n");
+        out.push("export default run");
         return out.join("");
     },
     compile: function(this: TemplateBase) {},
     dependency: {}


diff --git a/standalone.index.es6.njs.ts b/standalone.index.es6.njs.ts
index 0000000..0000000
@@ -4,18 +4,22 @@
         "standalone.index.es6.njs"
     ],
     script: function(files, _content, partial, slot, options) {
         var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
         for(let i = 0; i < files.length; i += 1){
             out.push("\n");
-            out.push("  import " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + " from '" + (files[i].path) + "'");
+            out.push("  import " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + " from '" + (files[i].path) + "'\n");
         }
         out.push("\n");
         out.push("\n");
-        out.push("const templates = {");
+        out.push("const templates = {\n");
         for(let i = 0; i < files.length; i += 1){
             out.push("\n");
-            out.push("  '" + (files[i].name) + "': " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + ",");
+            out.push("  '" + (files[i].name) + "': " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + ",\n");
         }
         out.push("\n");
         out.push("}\n");
         out.push("export default templates");


diff --git a/standalone.index.njs.ts b/standalone.index.njs.ts
index 0000000..0000000
@@ -4,12 +4,15 @@
         "standalone.index.njs"
     ],
     script: function(files, _content, partial, slot, options) {
         var out: Array<string> = [];
-        out.push("const templates = {");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("const templates = {\n");
         for(let i = 0; i < files.length; i += 1){
             out.push("\n");
-            out.push("  '" + (files[i].name) + "': require('" + (files[i].path) + "'),");
+            out.push("  '" + (files[i].name) + "': require('" + (files[i].path) + "'),\n");
         }
         out.push("\n");
         out.push("}\n");
         out.push("module.exports = templates");


diff --git a/standalone.index.ts.njs.ts b/standalone.index.ts.njs.ts
index 0000000..0000000
@@ -4,18 +4,22 @@
         "standalone.index.ts.njs"
     ],
     script: function(files, _content, partial, slot, options) {
         var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
         for(let i = 0; i < files.length; i += 1){
             out.push("\n");
-            out.push("  import " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + " from '" + (files[i].path) + "'");
+            out.push("  import " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + " from '" + (files[i].path) + "'\n");
         }
         out.push("\n");
         out.push("\n");
-        out.push("const templates = {");
+        out.push("const templates = {\n");
         for(let i = 0; i < files.length; i += 1){
             out.push("\n");
-            out.push("  '" + (files[i].name) + "': " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + ",");
+            out.push("  '" + (files[i].name) + "': " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + ",\n");
         }
         out.push("\n");
         out.push("}\n");
         out.push("export default templates");


diff --git a/standalone.njs.ts b/standalone.njs.ts
index 0000000..0000000
@@ -4,14 +4,18 @@
         "standalone.njs"
     ],
     script: function(files, _content, partial, slot, options) {
         var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
         out.push('const Factory = require("fte.js-standalone").TemplateFactoryStandalone;\n');
         out.push("\n");
-        out.push("const templates = {");
+        out.push("const templates = {\n");
         for(let i = 0; i < files.length; i += 1){
             out.push("\n");
-            out.push("  '" + (files[i].name) + "': require('" + (files[i].path) + "'),");
+            out.push("  '" + (files[i].name) + "': require('" + (files[i].path) + "'),\n");
         }
         out.push("\n");
         out.push("}\n");
         out.push("\n");


diff --git a/standalone.ts.njs.ts b/standalone.ts.njs.ts
index 0000000..0000000
@@ -4,19 +4,24 @@
         "standalone.ts.njs"
     ],
     script: function(files, _content, partial, slot, options) {
         var out: Array<string> = [];
-        out.push('import { TemplateFactoryStandalone as Factory } from "fte.js-standalone";');
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push('import { TemplateFactoryStandalone as Factory } from "fte.js-standalone";\n');
+        out.push("\n");
         for(let i = 0; i < files.length; i += 1){
             out.push("\n");
-            out.push("  import " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + " from '" + (files[i].path) + "'");
+            out.push("  import " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + " from '" + (files[i].path) + "'\n");
         }
         out.push("\n");
         out.push("\n");
-        out.push("const templates = {");
+        out.push("const templates = {\n");
         for(let i = 0; i < files.length; i += 1){
             out.push("\n");
-            out.push("  '" + (files[i].name) + "': " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + ",");
+            out.push("  '" + (files[i].name) + "': " + (files[i].name.replaceAll(/[\s\.]/g, "_")) + ",\n");
         }
         out.push("\n");
         out.push("}\n");
         out.push("\n");


diff --git a/typedefinitions.njs.ts b/typedefinitions.njs.ts
index 0000000..0000000
@@ -8,23 +8,27 @@
             if (ctx === undefined || ctx === null) ctx = typedefs;
             return _content(blockName, ctx, content, partial, slot);
         }
         var out: Array<string> = [];
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
+        out.push("\n");
         typedefs.forEach(({ params , types , name  })=>{
             out.push("\n");
             out.push(" // function " + (name) + "\n");
             out.push(" ");
             params.forEach((param)=>{
                 out.push("\n");
-                out.push((options.applyIndent(content("info", param), "  ")) + "\n");
+                out.push("  " + (content("info", param)) + "\n");
                 out.push(" ");
             });
             out.push("\n");
             out.push("\n");
             out.push(" ");
             types.filter((f)=>f.type !== "primitive" && f.type !== "function").forEach((param)=>{
                 out.push("\n");
-                out.push((options.applyIndent(content("info", param), "  ")) + "\n");
+                out.push("  " + (content("info", param)) + "\n");
                 out.push(" ");
             });
             out.push("\n");
         });
@@ -34,13 +38,16 @@
     },
     blocks: {
         "info": function(info, _content, partial, slot, options) {
             var out: Array<string> = [];
+            out.push("\n");
+            out.push("\n");
+            out.push("\n");
             out.push((info.name) + "\n");
             out.push((info.type) + "\n");
             info.properties.forEach((prop)=>{
                 out.push("\n");
-                out.push((options.applyIndent(prop.name, "  ")) + ": any\n");
+                out.push("  " + (prop.name) + ": any\n");
             });
             out.push("");
             return out.join("");
         }

