{"version":3,"sources":["generators_new/templates/graphql/graphql.njs.js"],"names":["text","code","expression"],"mappings":"AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAACA,sFACAA,sCACAA,yEACAA,sCACAA,IACAA,WACAA,iBACAA,uBACAA,mCACAA,IACAA,4DACAA,0DACAA,IA0CWA,IACXA,IACAC;AAxDD,IAwDCA,AACAA;AAzDD,IAyDCA,AACAA;AA1DD,IA0DCA,AACAA;AA3DD,IA2DCA,AACAA;AA5DD,IA4DCA,AACAA;AA7DD,IA6DCA,AACAA;AA9DD,IA8DCA,AACAA;AA/DD,IA+DCA,AACAA;AAhED,IAgECA,AACAA;AAjED,IAiECA,AACAA;AAlED,IAkECA,AACAA;AAnED,IAmECA,AACAA;AApED,IAoECA,AACAA;AArED,IAqECA,AACAA;AAtED,IAsECA,AACAA;AAvED,IAuECA,AACAA;AAxED,IAwECA,AACAA;AAzED,IAyECA,AACAA;AA1ED,IA0ECA,AACAA;AA3ED,IA2ECA,AACAA;AA5ED,IA4ECA,AACAA;AA7ED,IA6ECA,AAAED,IACFA,IACAC;AA/ED,IA+ECA,AAAgDD,IAChDA,oBACAA,IACAC;AAlFD,IAkFCA,AAAoBD,IACpBA,8BACAA,mBACAA,QAAME,oBAAqBA,eAAgBF,UAAQE,oBAAqBF,IACxEA,YAAUE,oBAAqBA,eAAgBF,WAC/CA,UAAQE,oBAAqBA,eAAgBF,IAC7CA,UAAQC;AAxFT,IAwFSA,AAAsCD,IAC9CA,YAAUE,yBAA0BF,IACpCA,UAAQC;AA1FT,IA0FSA,AAAOD,IACfA,UACAA,4BACAA,8CACAA,SACAA,MACAA,IACAA,uCACAA,aAAWE,oBAAqBA,eAAgBF,YAChDA,UAAQC;AAnGT,IAmGSA,AAAsCD,IAC9CA,UAAQE,yBAA0BF,IAClCA,UAAQC;AArGT,IAqGSA,AAAOD,IACfA,WACAA,qBACAA,UAAQC;AAxGT,IAwGSA,AAAqCD,IAC7CA,YAAUE,yBAA0BF,MAAGE,MAAOF,OAC9CA,UAAQC;AA1GT,IA0GSA,AAAMD,IACdA,WACAC;AA5GD,IA4GCA,AAAKD,IACLA,2BACAA,iBACAA,QAAME,oBAAqBA,eAAgBF,UAAQE,oBAAqBF,IACxEA,WAASE,oBAAqBA,eAAgBF,MAC9CA,QAAME,8BAA+BF,IACrCA,UACAA,OACAA,iBACAA,MAAIC;AArHL,IAqHKA,AACJA;AAtHD,IAsHCA,AACAA;AAvHD,IAuHCA,AAAoBD,IACpBA,6BACAA,MAAIC;AAzHL,IAyHKA,AAAKD,IACTA,MAAIC;AA1HL,IA0HKA,AAAsCD,IAC1CA,mCACAA,MAAIC;AA5HL,IA4HKA,AAAMD,IACVA,MAAIC;AA7HL,IA6HKA,AAA6BD,IACjCA,kDACAA,qBACAA,UACAA,MAAIC;AAjIL,IAiIKA,AAAOD,IACXC;AAlID,IAkICA,AACAA;AAnID,IAmICA,AACAA;AApID,IAoICA,AAAgGD,IAChGA,IAAEC;AArIH,IAqIGA,AAA4DD,IAC9DA,QAAMC;AAtIP,IAsIOA,AAAmCD,IACzCA,QAAME,OAAQF,qDACdA,kCAA+BE,uBAAwBF,OACvDA,+BACAA,iDACAA,aACAA,wBACAA,iDACAA,aACAA,qBACAA,sCACAA,aACAA,0BACAA,YACAA,QAAMC;AApJP,IAoJOA,AAAYD,IAClBA,UAAQC;AArJT,IAqJSA,AAA0CD,IAClDA,QAAME,OAAQF,6CAA0CE,uBAAwBF,QAChFA,UAAQC;AAvJT,IAuJSA,AAAOD,IACfA,QAAMC;AAxJP,IAwJOA,AAAMD,IACZA,MAAIC;AAzJL,IAyJKA,AAAMD,IACVA,OACAA,MACAA,IACAA,IACAA,mBACAA,iBACAA,oBACAA,6BACAA,UAAQE,oBAAqBA,eAAgBF,KAC7CA,+BACAA,8BACAA,8BACAA,0CAAwCC;AAtKzC,IAsKyCA,AAAmBD,SAAOE,wCAAyCD;AAtK5G,IAsK4GA,AAAKD,MAAIE,oBAAqBA,eAAgBD;AAtK1J,IAsK0JA,AAAkBD,OAAKC;AAtKjL,IAsKiLA,AAAKD,KACrLA,WACAA,UACAA,8BACAA,0BAAwBE,sBAAuBF,MAC/CA,uBAAqBE,mBAAoBF,MACzCA,sBAAoBC;AA5KrB,IA4KqBA,AAAkBD,MAAIC;AA5K3C,IA4K2CA,AAAYD,OAAKC;AA5K5D,IA4K4DA,AAAKD,KAChEA,qBAAmBC;AA7KpB,IA6KoBA,AAAwBD,MAAIC;AA7KhD,IA6KgDA,AAAYD,OAAKC;AA7KjE,IA6KiEA,AAAKD,KACrEA,yBACAA,YAAUC;AA/KX,IA+KWA,AAAuCD,IACjDA,cAAWE,MAAOF,OAClBA,YAAUC;AAjLX,IAiLWA,AAAOD,IACjBA,aACAA,YACAA,SACAA,SACAA,IACAA,iBACAA,oBACAA,6BACAA,UAAQE,oBAAqBA,eAAgBF,UAC7CA,+BACAA,8BACAA,8BACAA,0CAAwCC;AA9LzC,IA8LyCA,AAAmBD,SAAOE,wCAAyCD;AA9L5G,IA8L4GA,AAAKD,UAChHA,WACAA,UACAA,oCACAA,0BAAwBE,sBAAuBF,MAC/CA,uBAAqBE,mBAAoBF,MACzCA,sBAAoBC;AApMrB,IAoMqBA,AAAkBD,MAAIC;AApM3C,IAoM2CA,AAAYD,OAAKC;AApM5D,IAoM4DA,AAAKD,KAChEA,qBAAmBC;AArMpB,IAqMoBA,AAAwBD,MAAIC;AArMhD,IAqMgDA,AAAYD,OAAKC;AArMjE,IAqMiEA,AAAKD,KACrEA,yBACAA,YAAUC;AAvMX,IAuMWA,AAAuCD,IACjDA,cAAWE,MAAOF,OAClBA,YAAUC;AAzMX,IAyMWA,AAAOD,IACjBA,aACAA,YACAA,SACAA,SACAA,KACAA,MACAA,kBAAgBE,oBAAqBA,eAAgBF,mBACrDA,WAASE,oBAAqBA,eAAgBF,MAC9CA,6BACAA,IAAEC;AAnNH,IAmNGA,AAAkBD,IACpBA,cACAA,eACAA,IAAEC;AAtNH,IAsNGA,AAAKD,IACPA,QACAA,QACAA;AAzND;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","file":"generators_new/templates/graphql/graphql.njs.js","sourceRoot":"/Users/vedmalex/work/fte2/demo","sourcesContent":["const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"],"template":{"version":"1.0.0","segments":[{"generatedLine":1,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":2,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":3,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":4,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":5,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":6,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":7,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":8,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":9,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":10,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":11,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":12,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":13,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":14,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":15,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":16,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":17,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":18,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":19,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":20,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":21,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":22,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":23,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":24,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":25,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":26,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":27,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":28,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":29,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":30,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":31,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":32,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":33,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":34,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":35,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":36,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":37,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":38,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":39,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":40,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":41,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":42,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":43,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":44,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":45,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":46,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":47,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":48,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":49,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":50,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":51,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":52,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":53,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":54,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":55,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":56,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":57,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":58,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":59,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":60,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":61,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":62,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":63,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":64,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":65,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":66,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":67,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":68,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":69,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":70,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":71,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":72,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":73,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":74,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":75,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":76,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":77,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":78,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":79,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":80,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":81,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":82,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":83,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":84,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":85,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":86,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":87,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":88,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":89,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":90,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":91,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":92,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":93,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":94,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":95,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":96,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":97,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":98,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":99,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":100,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":101,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":102,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":103,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":104,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":105,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":106,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":107,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":108,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":109,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":110,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":111,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":112,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":113,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":114,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":115,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":116,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":117,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":118,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":119,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":120,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":121,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":122,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":123,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":124,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":125,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":126,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":127,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":128,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":129,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":130,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":131,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":132,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":133,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":134,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":135,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":136,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":137,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":138,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":139,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":140,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":141,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":142,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":143,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":144,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":145,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":146,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":147,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":148,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":149,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":150,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":151,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":152,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":153,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":154,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":155,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":156,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":157,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":158,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":159,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":160,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":161,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":162,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":163,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":164,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":165,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":166,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":167,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":168,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":169,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":170,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":171,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":172,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":173,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":174,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":175,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":176,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":177,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":178,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":179,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":180,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":181,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":182,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":183,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":184,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":185,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":186,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":187,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":188,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":189,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":190,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":191,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":192,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":193,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":194,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":195,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":196,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":197,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":198,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":199,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":200,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":201,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":202,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":203,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":204,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":205,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":206,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":207,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":208,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":209,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":210,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":211,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":212,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":213,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":214,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":215,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":216,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":217,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":218,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":219,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":220,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":221,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":222,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":223,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":224,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":225,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":226,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":227,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":228,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":229,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":230,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":231,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":232,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":233,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":234,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":235,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":236,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":237,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":238,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":239,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":240,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":241,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":242,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":243,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":244,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":245,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":246,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":247,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":248,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":249,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":250,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":251,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":252,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":253,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":254,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":255,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":256,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":257,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":258,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":259,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":260,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":261,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":262,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":263,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":264,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":265,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":266,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":267,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":268,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":269,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":270,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":271,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":272,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":273,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":274,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":275,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":276,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":277,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":278,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":279,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":280,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":281,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":282,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":283,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":284,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":285,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":286,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":287,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":288,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":289,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":290,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":291,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":292,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":293,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":294,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":295,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":296,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":297,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":298,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":299,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":300,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":301,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":302,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":303,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":304,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":305,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":306,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":307,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":308,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":309,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":310,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":311,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":312,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":313,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":314,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":315,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":316,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":317,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":318,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":319,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":320,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":321,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":322,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":323,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":324,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":325,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":326,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":327,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":328,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":329,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":330,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":331,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":332,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":333,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":334,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":335,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":336,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":337,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":338,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":339,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":340,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":341,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":342,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":343,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":344,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":345,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":346,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":347,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":348,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":349,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":350,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":351,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":352,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":353,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":354,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":355,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators_new/templates/graphql/graphql.njs.js"},{"generatedLine":11,"generatedColumn":4,"originalLine":1,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":90,"originalLine":2,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":128,"originalLine":3,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":201,"originalLine":4,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":239,"originalLine":5,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":243,"originalLine":6,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":254,"originalLine":7,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":271,"originalLine":8,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":294,"originalLine":9,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":329,"originalLine":10,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":333,"originalLine":11,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":393,"originalLine":12,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":451,"originalLine":13,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":455,"originalLine":55,"originalColumn":12,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":459,"originalLine":56,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":11,"generatedColumn":463,"originalLine":57,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":12,"generatedColumn":4,"originalLine":57,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":12,"generatedColumn":4,"originalLine":58,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":13,"generatedColumn":4,"originalLine":58,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":13,"generatedColumn":4,"originalLine":59,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":14,"generatedColumn":4,"originalLine":59,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":14,"generatedColumn":4,"originalLine":60,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":15,"generatedColumn":4,"originalLine":60,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":15,"generatedColumn":4,"originalLine":61,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":16,"generatedColumn":4,"originalLine":61,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":16,"generatedColumn":4,"originalLine":62,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":17,"generatedColumn":4,"originalLine":62,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":17,"generatedColumn":4,"originalLine":63,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":18,"generatedColumn":4,"originalLine":63,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":18,"generatedColumn":4,"originalLine":64,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":19,"generatedColumn":4,"originalLine":64,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":19,"generatedColumn":4,"originalLine":65,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":20,"generatedColumn":4,"originalLine":65,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":20,"generatedColumn":4,"originalLine":66,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":21,"generatedColumn":4,"originalLine":66,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":21,"generatedColumn":4,"originalLine":67,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":22,"generatedColumn":4,"originalLine":67,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":22,"generatedColumn":4,"originalLine":68,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":23,"generatedColumn":4,"originalLine":68,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":23,"generatedColumn":4,"originalLine":69,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":24,"generatedColumn":4,"originalLine":69,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":24,"generatedColumn":4,"originalLine":70,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":25,"generatedColumn":4,"originalLine":70,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":25,"generatedColumn":4,"originalLine":71,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":26,"generatedColumn":4,"originalLine":71,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":26,"generatedColumn":4,"originalLine":72,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":27,"generatedColumn":4,"originalLine":72,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":27,"generatedColumn":4,"originalLine":73,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":28,"generatedColumn":4,"originalLine":73,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":28,"generatedColumn":4,"originalLine":74,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":29,"generatedColumn":4,"originalLine":74,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":29,"generatedColumn":4,"originalLine":75,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":30,"generatedColumn":4,"originalLine":75,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":30,"generatedColumn":4,"originalLine":76,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":31,"generatedColumn":4,"originalLine":76,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":31,"generatedColumn":4,"originalLine":77,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":32,"generatedColumn":4,"originalLine":77,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":32,"generatedColumn":4,"originalLine":78,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":33,"generatedColumn":4,"originalLine":78,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":33,"generatedColumn":4,"originalLine":78,"originalColumn":3,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":33,"generatedColumn":8,"originalLine":79,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":33,"generatedColumn":12,"originalLine":80,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":34,"generatedColumn":4,"originalLine":80,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":34,"generatedColumn":4,"originalLine":80,"originalColumn":49,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":34,"generatedColumn":8,"originalLine":81,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":34,"generatedColumn":28,"originalLine":82,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":34,"generatedColumn":32,"originalLine":83,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":4,"originalLine":83,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":4,"originalLine":83,"originalColumn":21,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":8,"originalLine":84,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":38,"originalLine":85,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":57,"originalLine":86,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":65,"originalLine":86,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":85,"originalLine":86,"originalColumn":28,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":100,"originalLine":86,"originalColumn":44,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":110,"originalLine":86,"originalColumn":52,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":130,"originalLine":86,"originalColumn":73,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":134,"originalLine":87,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":146,"originalLine":87,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":166,"originalLine":87,"originalColumn":32,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":181,"originalLine":87,"originalColumn":48,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":192,"originalLine":88,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":202,"originalLine":88,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":222,"originalLine":88,"originalColumn":30,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":237,"originalLine":88,"originalColumn":46,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":241,"originalLine":89,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":35,"generatedColumn":251,"originalLine":89,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":36,"generatedColumn":4,"originalLine":89,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":36,"generatedColumn":4,"originalLine":89,"originalColumn":47,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":36,"generatedColumn":8,"originalLine":90,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":36,"generatedColumn":20,"originalLine":90,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":36,"generatedColumn":45,"originalLine":90,"originalColumn":37,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":36,"generatedColumn":49,"originalLine":91,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":36,"generatedColumn":59,"originalLine":91,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":4,"originalLine":91,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":4,"originalLine":91,"originalColumn":16,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":8,"originalLine":92,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":18,"originalLine":93,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":46,"originalLine":94,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":92,"originalLine":95,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":101,"originalLine":96,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":107,"originalLine":97,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":111,"originalLine":98,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":150,"originalLine":99,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":163,"originalLine":99,"originalColumn":12,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":183,"originalLine":99,"originalColumn":33,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":198,"originalLine":99,"originalColumn":49,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":210,"originalLine":100,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":37,"generatedColumn":220,"originalLine":100,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":38,"generatedColumn":4,"originalLine":100,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":38,"generatedColumn":4,"originalLine":100,"originalColumn":47,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":38,"generatedColumn":8,"originalLine":101,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":38,"generatedColumn":18,"originalLine":101,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":38,"generatedColumn":43,"originalLine":101,"originalColumn":35,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":38,"generatedColumn":47,"originalLine":102,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":38,"generatedColumn":57,"originalLine":102,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":39,"generatedColumn":4,"originalLine":102,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":39,"generatedColumn":4,"originalLine":102,"originalColumn":16,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":39,"generatedColumn":8,"originalLine":103,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":39,"generatedColumn":19,"originalLine":104,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":39,"generatedColumn":40,"originalLine":105,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":39,"generatedColumn":50,"originalLine":105,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":40,"generatedColumn":4,"originalLine":105,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":40,"generatedColumn":4,"originalLine":105,"originalColumn":46,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":40,"generatedColumn":8,"originalLine":106,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":40,"generatedColumn":20,"originalLine":106,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":40,"generatedColumn":45,"originalLine":106,"originalColumn":37,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":40,"generatedColumn":51,"originalLine":106,"originalColumn":40,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":40,"generatedColumn":57,"originalLine":106,"originalColumn":47,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":40,"generatedColumn":64,"originalLine":107,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":40,"generatedColumn":74,"originalLine":107,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":41,"generatedColumn":4,"originalLine":107,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":41,"generatedColumn":4,"originalLine":107,"originalColumn":15,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":41,"generatedColumn":8,"originalLine":108,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":41,"generatedColumn":19,"originalLine":109,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":4,"originalLine":109,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":4,"originalLine":109,"originalColumn":6,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":8,"originalLine":110,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":35,"originalLine":111,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":52,"originalLine":112,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":60,"originalLine":112,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":80,"originalLine":112,"originalColumn":28,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":95,"originalLine":112,"originalColumn":44,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":105,"originalLine":112,"originalColumn":52,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":125,"originalLine":112,"originalColumn":73,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":129,"originalLine":113,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":140,"originalLine":113,"originalColumn":10,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":160,"originalLine":113,"originalColumn":31,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":175,"originalLine":113,"originalColumn":47,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":181,"originalLine":114,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":189,"originalLine":114,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":219,"originalLine":114,"originalColumn":38,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":223,"originalLine":115,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":233,"originalLine":116,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":240,"originalLine":117,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":257,"originalLine":118,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":42,"generatedColumn":263,"originalLine":118,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":43,"generatedColumn":4,"originalLine":118,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":43,"generatedColumn":4,"originalLine":119,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":44,"generatedColumn":4,"originalLine":119,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":44,"generatedColumn":4,"originalLine":120,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":45,"generatedColumn":4,"originalLine":120,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":45,"generatedColumn":4,"originalLine":120,"originalColumn":21,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":45,"generatedColumn":8,"originalLine":121,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":45,"generatedColumn":37,"originalLine":122,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":45,"generatedColumn":43,"originalLine":122,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":46,"generatedColumn":4,"originalLine":122,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":46,"generatedColumn":4,"originalLine":122,"originalColumn":10,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":46,"generatedColumn":8,"originalLine":123,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":46,"generatedColumn":14,"originalLine":123,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":47,"generatedColumn":4,"originalLine":123,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":47,"generatedColumn":4,"originalLine":123,"originalColumn":43,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":47,"generatedColumn":8,"originalLine":124,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":47,"generatedColumn":43,"originalLine":125,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":47,"generatedColumn":49,"originalLine":125,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":48,"generatedColumn":4,"originalLine":125,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":48,"generatedColumn":4,"originalLine":125,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":48,"generatedColumn":8,"originalLine":126,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":48,"generatedColumn":14,"originalLine":126,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":49,"generatedColumn":4,"originalLine":126,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":49,"generatedColumn":4,"originalLine":126,"originalColumn":34,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":49,"generatedColumn":8,"originalLine":127,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":49,"generatedColumn":58,"originalLine":128,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":49,"generatedColumn":79,"originalLine":129,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":49,"generatedColumn":89,"originalLine":130,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":49,"generatedColumn":95,"originalLine":130,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":50,"generatedColumn":4,"originalLine":130,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":50,"generatedColumn":4,"originalLine":130,"originalColumn":12,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":50,"generatedColumn":8,"originalLine":131,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":51,"generatedColumn":4,"originalLine":131,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":51,"generatedColumn":4,"originalLine":132,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":52,"generatedColumn":4,"originalLine":132,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":52,"generatedColumn":4,"originalLine":133,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":53,"generatedColumn":4,"originalLine":133,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":53,"generatedColumn":4,"originalLine":133,"originalColumn":97,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":53,"generatedColumn":8,"originalLine":134,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":53,"generatedColumn":12,"originalLine":134,"originalColumn":3,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":54,"generatedColumn":4,"originalLine":134,"originalColumn":3,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":54,"generatedColumn":4,"originalLine":134,"originalColumn":63,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":54,"generatedColumn":8,"originalLine":135,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":54,"generatedColumn":16,"originalLine":135,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":4,"originalLine":135,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":4,"originalLine":135,"originalColumn":42,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":8,"originalLine":136,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":16,"originalLine":136,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":23,"originalLine":136,"originalColumn":15,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":76,"originalLine":137,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":110,"originalLine":137,"originalColumn":32,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":133,"originalLine":137,"originalColumn":56,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":140,"originalLine":138,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":171,"originalLine":139,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":220,"originalLine":140,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":233,"originalLine":141,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":257,"originalLine":142,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":306,"originalLine":143,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":319,"originalLine":144,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":340,"originalLine":145,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":378,"originalLine":146,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":391,"originalLine":147,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":417,"originalLine":148,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":429,"originalLine":149,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":55,"generatedColumn":437,"originalLine":149,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":56,"generatedColumn":4,"originalLine":149,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":56,"generatedColumn":4,"originalLine":149,"originalColumn":19,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":56,"generatedColumn":8,"originalLine":150,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":56,"generatedColumn":18,"originalLine":150,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":57,"generatedColumn":4,"originalLine":150,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":57,"generatedColumn":4,"originalLine":150,"originalColumn":51,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":57,"generatedColumn":8,"originalLine":151,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":57,"generatedColumn":16,"originalLine":151,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":57,"generatedColumn":23,"originalLine":151,"originalColumn":15,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":57,"generatedColumn":68,"originalLine":151,"originalColumn":57,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":57,"generatedColumn":91,"originalLine":151,"originalColumn":81,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":57,"generatedColumn":99,"originalLine":152,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":57,"generatedColumn":109,"originalLine":152,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":58,"generatedColumn":4,"originalLine":152,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":58,"generatedColumn":4,"originalLine":152,"originalColumn":16,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":58,"generatedColumn":8,"originalLine":153,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":58,"generatedColumn":16,"originalLine":153,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":59,"generatedColumn":4,"originalLine":153,"originalColumn":7,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":59,"generatedColumn":4,"originalLine":153,"originalColumn":13,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":59,"generatedColumn":8,"originalLine":154,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":59,"generatedColumn":14,"originalLine":154,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":4,"originalLine":154,"originalColumn":5,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":4,"originalLine":154,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":8,"originalLine":155,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":15,"originalLine":156,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":21,"originalLine":157,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":25,"originalLine":158,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":29,"originalLine":159,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":48,"originalLine":160,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":65,"originalLine":161,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":85,"originalLine":162,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":114,"originalLine":163,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":124,"originalLine":163,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":144,"originalLine":163,"originalColumn":30,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":159,"originalLine":163,"originalColumn":46,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":164,"originalLine":164,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":195,"originalLine":165,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":225,"originalLine":166,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":255,"originalLine":167,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":60,"generatedColumn":297,"originalLine":167,"originalColumn":41,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":61,"generatedColumn":4,"originalLine":167,"originalColumn":41,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":61,"generatedColumn":4,"originalLine":167,"originalColumn":60,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":61,"generatedColumn":13,"originalLine":167,"originalColumn":67,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":61,"generatedColumn":53,"originalLine":167,"originalColumn":108,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":62,"generatedColumn":4,"originalLine":167,"originalColumn":108,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":62,"generatedColumn":4,"originalLine":167,"originalColumn":113,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":62,"generatedColumn":10,"originalLine":167,"originalColumn":117,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":62,"generatedColumn":30,"originalLine":167,"originalColumn":138,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":62,"generatedColumn":45,"originalLine":167,"originalColumn":154,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":63,"generatedColumn":4,"originalLine":167,"originalColumn":154,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":63,"generatedColumn":4,"originalLine":167,"originalColumn":172,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":63,"generatedColumn":11,"originalLine":167,"originalColumn":177,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":4,"originalLine":167,"originalColumn":177,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":4,"originalLine":167,"originalColumn":182,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":9,"originalLine":168,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":20,"originalLine":169,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":30,"originalLine":170,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":60,"originalLine":171,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":86,"originalLine":171,"originalColumn":25,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":108,"originalLine":171,"originalColumn":48,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":114,"originalLine":172,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":137,"originalLine":172,"originalColumn":22,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":156,"originalLine":172,"originalColumn":42,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":162,"originalLine":173,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":64,"generatedColumn":184,"originalLine":173,"originalColumn":21,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":65,"generatedColumn":4,"originalLine":173,"originalColumn":21,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":65,"generatedColumn":4,"originalLine":173,"originalColumn":39,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":65,"generatedColumn":10,"originalLine":173,"originalColumn":43,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":66,"generatedColumn":4,"originalLine":173,"originalColumn":43,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":66,"generatedColumn":4,"originalLine":173,"originalColumn":55,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":66,"generatedColumn":11,"originalLine":173,"originalColumn":60,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":67,"generatedColumn":4,"originalLine":173,"originalColumn":60,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":67,"generatedColumn":4,"originalLine":173,"originalColumn":65,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":67,"generatedColumn":9,"originalLine":174,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":67,"generatedColumn":30,"originalLine":174,"originalColumn":20,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":68,"generatedColumn":4,"originalLine":174,"originalColumn":20,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":68,"generatedColumn":4,"originalLine":174,"originalColumn":44,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":68,"generatedColumn":10,"originalLine":174,"originalColumn":48,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":69,"generatedColumn":4,"originalLine":174,"originalColumn":48,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":69,"generatedColumn":4,"originalLine":174,"originalColumn":60,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":69,"generatedColumn":11,"originalLine":174,"originalColumn":65,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":70,"generatedColumn":4,"originalLine":174,"originalColumn":65,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":70,"generatedColumn":4,"originalLine":174,"originalColumn":70,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":70,"generatedColumn":9,"originalLine":175,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":70,"generatedColumn":34,"originalLine":176,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":70,"generatedColumn":46,"originalLine":176,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":71,"generatedColumn":4,"originalLine":176,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":71,"generatedColumn":4,"originalLine":176,"originalColumn":50,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":71,"generatedColumn":8,"originalLine":177,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":71,"generatedColumn":22,"originalLine":177,"originalColumn":12,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":71,"generatedColumn":28,"originalLine":177,"originalColumn":19,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":71,"generatedColumn":35,"originalLine":178,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":71,"generatedColumn":47,"originalLine":178,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":4,"originalLine":178,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":4,"originalLine":178,"originalColumn":18,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":8,"originalLine":179,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":21,"originalLine":180,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":33,"originalLine":181,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":42,"originalLine":182,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":51,"originalLine":183,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":55,"originalLine":184,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":72,"originalLine":185,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":92,"originalLine":186,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":121,"originalLine":187,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":131,"originalLine":187,"originalColumn":9,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":151,"originalLine":187,"originalColumn":30,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":166,"originalLine":187,"originalColumn":46,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":176,"originalLine":188,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":207,"originalLine":189,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":237,"originalLine":190,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":267,"originalLine":191,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":72,"generatedColumn":309,"originalLine":191,"originalColumn":41,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":73,"generatedColumn":4,"originalLine":191,"originalColumn":41,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":73,"generatedColumn":4,"originalLine":191,"originalColumn":60,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":73,"generatedColumn":13,"originalLine":191,"originalColumn":67,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":73,"generatedColumn":53,"originalLine":191,"originalColumn":108,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":4,"originalLine":191,"originalColumn":108,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":4,"originalLine":191,"originalColumn":113,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":14,"originalLine":192,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":25,"originalLine":193,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":35,"originalLine":194,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":71,"originalLine":195,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":97,"originalLine":195,"originalColumn":25,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":119,"originalLine":195,"originalColumn":48,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":125,"originalLine":196,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":148,"originalLine":196,"originalColumn":22,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":167,"originalLine":196,"originalColumn":42,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":173,"originalLine":197,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":74,"generatedColumn":195,"originalLine":197,"originalColumn":21,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":75,"generatedColumn":4,"originalLine":197,"originalColumn":21,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":75,"generatedColumn":4,"originalLine":197,"originalColumn":39,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":75,"generatedColumn":10,"originalLine":197,"originalColumn":43,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":76,"generatedColumn":4,"originalLine":197,"originalColumn":43,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":76,"generatedColumn":4,"originalLine":197,"originalColumn":55,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":76,"generatedColumn":11,"originalLine":197,"originalColumn":60,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":77,"generatedColumn":4,"originalLine":197,"originalColumn":60,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":77,"generatedColumn":4,"originalLine":197,"originalColumn":65,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":77,"generatedColumn":9,"originalLine":198,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":77,"generatedColumn":30,"originalLine":198,"originalColumn":20,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":78,"generatedColumn":4,"originalLine":198,"originalColumn":20,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":78,"generatedColumn":4,"originalLine":198,"originalColumn":44,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":78,"generatedColumn":10,"originalLine":198,"originalColumn":48,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":79,"generatedColumn":4,"originalLine":198,"originalColumn":48,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":79,"generatedColumn":4,"originalLine":198,"originalColumn":60,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":79,"generatedColumn":11,"originalLine":198,"originalColumn":65,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":80,"generatedColumn":4,"originalLine":198,"originalColumn":65,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":80,"generatedColumn":4,"originalLine":198,"originalColumn":70,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":80,"generatedColumn":9,"originalLine":199,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":80,"generatedColumn":34,"originalLine":200,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":80,"generatedColumn":46,"originalLine":200,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":81,"generatedColumn":4,"originalLine":200,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":81,"generatedColumn":4,"originalLine":200,"originalColumn":50,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":81,"generatedColumn":8,"originalLine":201,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":81,"generatedColumn":22,"originalLine":201,"originalColumn":12,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":81,"generatedColumn":28,"originalLine":201,"originalColumn":19,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":81,"generatedColumn":35,"originalLine":202,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":81,"generatedColumn":47,"originalLine":202,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":4,"originalLine":202,"originalColumn":11,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":4,"originalLine":202,"originalColumn":18,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":8,"originalLine":203,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":21,"originalLine":204,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":33,"originalLine":205,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":42,"originalLine":206,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":51,"originalLine":207,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":56,"originalLine":208,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":62,"originalLine":209,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":80,"originalLine":209,"originalColumn":17,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":100,"originalLine":209,"originalColumn":38,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":115,"originalLine":209,"originalColumn":54,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":134,"originalLine":210,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":145,"originalLine":210,"originalColumn":10,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":165,"originalLine":210,"originalColumn":31,"source":"generators_new/templates/graphql/graphql.njs.js","name":"expression","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":180,"originalLine":210,"originalColumn":47,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":186,"originalLine":211,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":215,"originalLine":212,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":82,"generatedColumn":219,"originalLine":212,"originalColumn":3,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":83,"generatedColumn":4,"originalLine":212,"originalColumn":3,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":83,"generatedColumn":4,"originalLine":212,"originalColumn":21,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":83,"generatedColumn":8,"originalLine":213,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":83,"generatedColumn":22,"originalLine":214,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":83,"generatedColumn":37,"originalLine":215,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":83,"generatedColumn":41,"originalLine":215,"originalColumn":3,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":84,"generatedColumn":4,"originalLine":215,"originalColumn":3,"source":"generators_new/templates/graphql/graphql.njs.js","name":"code","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":84,"generatedColumn":4,"originalLine":215,"originalColumn":8,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":84,"generatedColumn":8,"originalLine":216,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":84,"generatedColumn":16,"originalLine":217,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"},{"generatedLine":84,"generatedColumn":24,"originalLine":218,"originalColumn":1,"source":"generators_new/templates/graphql/graphql.njs.js","name":"text","content":"const { Type, Query, Schema, Enum, Union} = require('@grainjs/gql-schema-builder')\nconst gql = require('graphql-tag')\nconst {registerSchema} = require(USEGLOBAL('graphql/registerSchema'))\nconst { get } = require('lodash');\n\nconst {\n  query_many,\n  query_many_count,\n} = require('@grainjs/loaders')\n\n// TODO: проверить как можно добавлять условия в запросы\n// условия, такие же как на запросной части приложения\n\n<#- block 'gqlprops' : -#>\n<#@ noContent #>\n<#-\n  const hasChilds = context.hasChilds(context.thingType)\n\n  var getType = function(name){\n    switch(name.toLowerCase()){\n      case 'int': return 'Int';\n      case 'integer': return 'Int';\n      case 'float': return 'Float';\n      case 'string': return 'String';\n      case 'date': return 'Date';\n      case 'boolean': return 'Boolean';\n      case 'id': return 'ID';\n    }\n  }\n  const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n  const has_ID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == '_id' )\n -#>\n<#- if(!hasID){-#>\n      id: ID\n<#  } -#>\n<#- if(!has_ID){ -#>\n      _id: ID\n<#  } -#>\n<#if(hasChilds || context.extends ){-#>\n      _tid: String\n<#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {\n    var pName = props[i].propertyName.replaceAll('.','');-#>\n    <#-if(props[i].type === 'date') {#>\n      #{pName}(format:String, zone: Float, json: Boolean): #{getType(props[i].type)}\n    <#-} else {#>\n    #{pName}: #{getType(props[i].type)}\n    <#- }-#>\n<#-}#>\n  <#-if(context.hasRels > 0) {#>\n    childRel:#{context.GQLName(context.thingType)}Edges\n  <#}#>\n<#- end -#>\n\n<#-\nvar inspect = require('util').inspect;\nconst hasChilds = context.hasChilds(context.thingType)\n\nfunction resolveThingName(thingType){\n  let [namespace, name] = thingType.split('.');\n  return { name, namespace }\n}\n\nconst GQLName = context.GQLName = function GQLName(thingType) {\n  return thingType.replaceAll('.','')\n}\n\n  var allRels = [];\n  allRels.push.apply(allRels,context.destRels);\n  allRels.push.apply(allRels,context.sourceRels);\n  var allNonEmbedded = allRels.filter(function(r){\n    return !r.oppositeEmbedded;\n  });\n  context.hasRels = allRels.length > 0\n\n#>\n\n<# var listing = inspect(context,{ depth:4 });#>\n/* # {listing}*/\n\n<# if(hasChilds) {#>\nconst tUnion = new Union({\n    schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    union #{context.$namespace}#{context.$name}Union =\n        #{context.$namespace}#{context.$name}\n        <#-context.allChilds.forEach(item=>{#>\n        | #{item.replaceAll('.','')}\n        <#-})#>\n    `,\n    resolver: (root)=> {\n      return root.__tid.replaceAll('.','')\n    }\n})\n\nconst tEnum = new Enum({schema:gql`\n      enum #{context.$namespace}#{context.$name}Childs {\n        <#-context.allChilds.forEach(item=>{#>\n        #{item.replaceAll('.','')}\n        <#-})#>\n      }\n    `, resolver:{\n        <#context.allChilds.forEach(item=>{#>\n          #{item.replaceAll('.','')}: \"#{item}\",\n        <#})#>\n    }})\n<#}#>\nconst main = new Type({\n  schema:gql`\n    # #{context.$namespace}#{context.$name} of the #{context.$namespace}\n    type #{context.$namespace}#{context.$name} {\n      #{content('gqlprops', context)}\n    }`\n  ,\n  resolver: {\n    <#\n      const hasID = context.properties.find(p=>p.propertyName.toLowerCase().trim() == 'id' )\n      if(!hasID) {#>\n    id: root => root._id,\n    <#}#>\n    <#if(hasChilds || context.extends ){#>\n      _tid: root => root.__tid,\n    <#}-#>\n    <#-if(allRels.length > 0) {#>\n    childRel: (root, args, context, info) => {\n      return root\n    },\n    <#-}-#>\n<#-\n  // properties\n  for (var i=0, props = context.properties ,proplen = props?.length ?? 0; i < proplen; i++) {-#>\n  <#- var pName = props[i].propertyName.replaceAll('.','');-#>\n      <#-if(props[i].type === 'date') {#>\n      #{pName}:(root, {format, zone, json}, context, info) => {\n        var result = get(root,\"#{props[i].propertyName}\")\n        if(format && zone){\n          return result.format(format, zone);\n        }\n        if (format){\n          return result.format(format, zone);\n        }\n        if(json){\n          return result?.toJSON();\n        }\n        return result;\n      },\n      <#} else {#>\n        <#-if(pName !== props[i].propertyName) {#>\n      #{pName}:(root, args, context, info) => get(root,\"#{props[i].propertyName}\"),\n        <#-}-#>\n      <#-}#>\n    <#-}#>\n  }\n})\n\n\nconst query = [\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): [#{context.$namespace}#{context.$name}<#if(hasChilds){#>Union<#}#>]\n      }\n    `,\n    resolver: query_many({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n\n  new Query({\n    schema: gql`\n      extend type Query {\n        #{context.$namespace}#{context.$name}Count(\n          onlyIds: Boolean,\n          ensure: Boolean,\n          absent: Boolean,\n          options: JSON, conditions:JSON<#if(hasChilds) {#>, kind:#{context.getEnumName(context.thingType)}<#}#>): Int\n      }\n    `,\n    resolver: query_many_count({\n        sourceLocation:'#{context.locationType}',\n        sourceModel:'#{context.thingType}',\n        hasChildren:<#if(hasChilds){#>true<#} else {#>false<#}#>,\n        hasExtends:<#if(context.extends){#>true<#} else {#>false<#}#>,\n        allChildren:[\n          <#-context.allChilds?.forEach(item=>{#>\n          \"#{item}\",\n          <#-})#>\n        ]\n      },\n    )\n  }),\n]\n//\nregisterSchema('#{context.$namespace}#{context.$name}', new Schema({\n  name: '#{context.$namespace}#{context.$name}',\n  items: [main, ...query,\n  <#if(hasChilds){#>\n    tEnum,\n    tUnion,\n  <#}#>\n  ],\n  })\n)\n"}]}}