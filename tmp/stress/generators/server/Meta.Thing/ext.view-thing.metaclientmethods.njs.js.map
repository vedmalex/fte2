{"version":3,"sources":["generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"],"names":["code","text","expression"],"mappings":"AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IACCA;AADD,IACCA,AACAA;AAFD,IAECA,AACAA;AAHD,IAGCA,AACAA;AAJD,IAICA,AACAA;AALD,IAKCA,AAAEC,IACFA,IACAA,IACAA,YACAA,6EACAA,sFACAA,+FACAA,wCACAA,wCAAsCC,oBAAqBD,GAACC,eAAgBD,QAC5EA,mCACAA,eACAA,yBAAuBC,oBAAqBD,GAACC,eAAgBD,QAC7DA,oBACAA,QAAMD;AAlBP,IAkBOA,AAAgDC,IACtDA,UAAQD;AAnBT,IAmBSA,AACRA;AApBD,IAoBCA,AACAA;AArBD,IAqBCA,AAAUC,IACVA,gBAAaC,cAAeD,gBAC5BA,gCACAA,sBAAmBC,cAAeD,OAClCA,0BAAuBC,cAAeD,2BAAqBC,oBAAqBD,GAACC,eAAgBD,gCACjGA,kCACAA,wBACAA,gBACAA,4BACAA,uBAAoBC,cAAeD,QAAIC,gBAAiBD,2BAAqBC,oBAAqBD,GAACC,eAAgBD,mBACnHA,kCACAA,qCACAA,mBAAiBC,cAAeD,MAChCA,6BACAA,6BACAA,gCACAA,eACAA,UAAQD;AAtCT,IAsCSA,AAAKC,IACbA,QAAMD;AAvCP,IAuCOA,AAAKC,IACXA,UAAQD;AAxCT,IAwCSA,AACRA;AAzCD,IAyCCA,AACAA;AA1CD,IA0CCA,AACAA;AA3CD,IA2CCA,AACAA;AA5CD,IA4CCA,AAAcC,IACdA,gBAAaC,sBAAuBD,cACpCA,mCACAA,2BAAwBC,sBAAuBD,OAC/CA,8BAA4BD;AAhD7B,IAgD6BA,AAAoCE,6CAA8CF;AAhD/G,IAgD+GA,AAAUE,sCAAuCF;AAhDhK,IAgDgKA,AAAKC,QAAMC,oBAAqBD,GAACC,eAAgBD,yBAAuBD;AAhDxO,IAgDwOA,AAAgCC,OAAIC,yBAA0BD,IAACD;AAhDvS,IAgDuSA,AAAKC,KAC3SA,gCAA8BC,8CAA+CD,KAC7EA,2BAAyBC,wCAAyCD,KAClEA,sBACAA,kCACAA,2BAAyBD;AArD1B,IAqD0BA,AAAoCE,6CAA8CF;AArD5G,IAqD4GA,AAAUE,sCAAuCF;AArD7J,IAqD6JA,AAAKC,IAAEC,oBAAqBD,GAACC,eAAgBD,gBAAaC,sBAAuBD,QAC7OA,sCACAA,kBAAgBD;AAvDjB,IAuDiBA,AAAyCC,IACzDA,oBAAkBD;AAxDnB,IAwDmBA,AAA2DC,IAC7EA,gCAA8BC,qBAAsBD,oBACpDA,oBAAkBD;AA1DnB,IA0DmBA,AAAOC,IACzBA,uCACAA,kBAAgBD;AA5DjB,IA4DiBA,AAAgDC,IAChEA,wCACAA,kBAAgBD;AA9DjB,IA8DiBA,AAAOC,IACvBA,qBACAA,cAAYD;AAhEb,IAgEaA,AACZA;AAjED,IAiECA,AACAA;AAlED,IAkECA,AAAUC,IACVA,YACAA,oBACAA,UAAQD;AArET,IAqESA,AACRA;AAtED,IAsECA,AACAA;AAvED,IAuECA,AAAUC,IACVA,oDACAA,6BACAA,kDAA+CC,gBAAiBD,OAChEA,+EACAA,2BAAwBC,oBAAqBD,GAACC,eAAgBD,OAC9DA,wCACAA,4BACAA,6BACAA,6BACAA,oBACAA,iCACAA,oDACAA,uEACAA,4DACAA,sEAAiEC,oBAAqBD,GAACC,eAAgBD,kBACvGA,gCACAA,yBACAA,IACAA,2CACAA,2CACAA,oCACAA,8BACAA,qCACAA,uBACAA,qBACAA,oBACAA,+BACAA,+CAA6CC,oBAAqBD,GAACC,eAAgBD,IAAEC,gBAAiBD,WACtGA,oBACAA,iBACAA,gBACAA,YAAUD;AAvGX,IAuGWA,AACVA;AAxGD,IAwGCA,AACAA;AAzGD,IAyGCA,AACAA;AA1GD,IA0GCA,AAAYC,IACZA,sBAAmBC,cAAeD,wCAClCA,+CACAA,qCACAA,6FAA2FC,oBAAqBD,GAACC,eAAgBD,iBAAeC,cAAeD,2BAC/JA,sCACAA,2CACAA,6CACAA,mBACAA,wDACAA,2CACAA,oDACAA,qFAAkFC,oBAAqBD,GAACC,eAAgBD,QACxHA,gDACAA,gCAA6BC,cAAeD,yBAC5CA,qBACAA,qBACAA,iBACAA,gBACAA,YAAUD;AA7HX,IA6HWA,AAAKC,IACfA,UAAQD;AA9HT,IA8HSA,AAAKC,IACbA,UAAQD;AA/HT,IA+HSA,AACRA;AAhID,IAgICA,AACAA;AAjID,IAiICA,AACAA;AAlID,IAkICA,AAAYC,IACZA,YAAUD;AAnIX,IAmIWA,AAA2BC,KAAGC,kBAAmBD,KAAGD;AAnI/D,IAmI+DA,AAAKC,IACnEA,cAAYC,eAAgBD,aAAWD;AApIxC,IAoIwCA,AAAwBE,iBAAkBF;AApIlF,IAoIkFA,AAAKC,MACtFA,uFAAqFC,oBAAqBD,GAACC,eAAgBD,kBAAgBC,eAAgBD,kBAAgBC,eAAgBD,SAC3LA,gBAAcC,eAAgBD,IAC9BA,kBACAA,UAAQD;AAxIT,IAwISA,AACRA;AAzID,IAyICA,AAAUC,IACVA,WACAA,SACAA,OACAA;AA7ID;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","file":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","sourceRoot":"/Users/vedmalex/work/fte2/demo","sourcesContent":["<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"],"template":{"version":"1.0.0","segments":[{"generatedLine":1,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":2,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":3,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":4,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":5,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":6,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":7,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":8,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":9,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":10,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":11,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":12,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":13,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":14,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":15,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":16,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":17,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":18,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":19,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":20,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":21,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":22,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":23,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":24,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":25,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":26,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":27,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":28,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":29,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":30,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":31,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":32,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":33,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":34,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":35,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":36,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":37,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":38,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":39,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":40,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":41,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":42,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":43,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":44,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":45,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":46,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":47,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":48,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":49,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":50,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":51,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":52,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":53,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":54,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":55,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":56,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":57,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":58,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":59,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":60,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":61,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":62,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":63,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":64,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":65,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":66,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":67,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":68,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":69,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":70,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":71,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":72,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":73,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":74,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":75,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":76,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":77,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":78,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":79,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":80,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":81,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":82,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":83,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":84,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":85,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":86,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":87,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":88,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":89,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":90,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":91,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":92,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":93,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":94,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":95,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":96,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":97,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":98,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":99,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":100,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":101,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":102,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":103,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":104,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":105,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":106,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":107,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":108,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":109,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":110,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":111,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":112,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":113,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":114,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":115,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":116,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":117,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":118,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":119,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":120,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":121,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":122,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":123,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":124,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":125,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":126,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":127,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":128,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":129,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":130,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":131,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":132,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":133,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":134,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":135,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":136,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":137,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":138,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":139,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":140,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":141,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":142,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":143,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":144,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":145,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":146,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":147,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":148,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":149,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":150,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":151,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":152,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":153,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":154,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":155,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":156,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":157,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":158,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":159,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":160,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":161,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":162,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":163,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":164,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":165,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":166,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":167,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":168,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":169,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":170,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":171,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":172,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":173,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":174,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":175,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":176,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":177,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":178,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":179,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":180,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":181,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":182,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":183,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":184,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":185,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":186,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":187,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":188,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":189,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":190,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":191,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":192,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":193,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":194,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":195,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":196,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":197,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":198,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":199,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":200,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":201,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":202,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":203,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":204,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":205,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":206,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":207,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":208,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":209,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":210,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":211,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":212,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":213,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":214,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":215,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":216,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js"},{"generatedLine":8,"generatedColumn":4,"originalLine":2,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":9,"generatedColumn":4,"originalLine":2,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":9,"generatedColumn":4,"originalLine":3,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":10,"generatedColumn":4,"originalLine":3,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":10,"generatedColumn":4,"originalLine":4,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":11,"generatedColumn":4,"originalLine":4,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":11,"generatedColumn":4,"originalLine":5,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":12,"generatedColumn":4,"originalLine":5,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":12,"generatedColumn":4,"originalLine":6,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":4,"originalLine":6,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":4,"originalLine":6,"originalColumn":3,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":8,"originalLine":7,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":12,"originalLine":8,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":16,"originalLine":9,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":28,"originalLine":10,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":105,"originalLine":11,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":191,"originalLine":12,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":286,"originalLine":13,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":326,"originalLine":14,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":366,"originalLine":14,"originalColumn":39,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":386,"originalLine":14,"originalColumn":60,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":389,"originalLine":14,"originalColumn":61,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":404,"originalLine":14,"originalColumn":77,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":412,"originalLine":15,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":447,"originalLine":16,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":462,"originalLine":17,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":487,"originalLine":17,"originalColumn":24,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":507,"originalLine":17,"originalColumn":45,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":510,"originalLine":17,"originalColumn":46,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":525,"originalLine":17,"originalColumn":62,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":533,"originalLine":18,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":553,"originalLine":19,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":13,"generatedColumn":561,"originalLine":19,"originalColumn":7,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":14,"generatedColumn":4,"originalLine":19,"originalColumn":7,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":14,"generatedColumn":4,"originalLine":19,"originalColumn":55,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":14,"generatedColumn":8,"originalLine":20,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":14,"generatedColumn":18,"originalLine":20,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":15,"generatedColumn":4,"originalLine":20,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":15,"generatedColumn":4,"originalLine":21,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":16,"generatedColumn":4,"originalLine":21,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":16,"generatedColumn":4,"originalLine":22,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":4,"originalLine":22,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":4,"originalLine":22,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":8,"originalLine":23,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":24,"originalLine":23,"originalColumn":14,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":38,"originalLine":23,"originalColumn":29,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":54,"originalLine":24,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":86,"originalLine":25,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":108,"originalLine":25,"originalColumn":20,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":122,"originalLine":25,"originalColumn":35,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":129,"originalLine":26,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":155,"originalLine":26,"originalColumn":24,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":169,"originalLine":26,"originalColumn":39,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":196,"originalLine":26,"originalColumn":60,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":216,"originalLine":26,"originalColumn":81,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":219,"originalLine":26,"originalColumn":82,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":234,"originalLine":26,"originalColumn":98,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":266,"originalLine":27,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":300,"originalLine":28,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":324,"originalLine":29,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":340,"originalLine":30,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":368,"originalLine":31,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":391,"originalLine":31,"originalColumn":21,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":405,"originalLine":31,"originalColumn":36,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":413,"originalLine":31,"originalColumn":40,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":429,"originalLine":31,"originalColumn":57,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":456,"originalLine":31,"originalColumn":78,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":476,"originalLine":31,"originalColumn":99,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":479,"originalLine":31,"originalColumn":100,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":494,"originalLine":31,"originalColumn":116,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":513,"originalLine":32,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":547,"originalLine":33,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":584,"originalLine":34,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":603,"originalLine":34,"originalColumn":18,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":617,"originalLine":34,"originalColumn":33,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":623,"originalLine":35,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":652,"originalLine":36,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":681,"originalLine":37,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":713,"originalLine":38,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":728,"originalLine":39,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":17,"generatedColumn":738,"originalLine":39,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":18,"generatedColumn":4,"originalLine":39,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":18,"generatedColumn":4,"originalLine":39,"originalColumn":14,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":18,"generatedColumn":8,"originalLine":40,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":18,"generatedColumn":16,"originalLine":40,"originalColumn":7,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":19,"generatedColumn":4,"originalLine":40,"originalColumn":7,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":19,"generatedColumn":4,"originalLine":40,"originalColumn":12,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":19,"generatedColumn":8,"originalLine":41,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":19,"generatedColumn":18,"originalLine":41,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":20,"generatedColumn":4,"originalLine":41,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":20,"generatedColumn":4,"originalLine":42,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":21,"generatedColumn":4,"originalLine":42,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":21,"generatedColumn":4,"originalLine":43,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":22,"generatedColumn":4,"originalLine":43,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":22,"generatedColumn":4,"originalLine":44,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":23,"generatedColumn":4,"originalLine":44,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":23,"generatedColumn":4,"originalLine":45,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":4,"originalLine":45,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":4,"originalLine":45,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":8,"originalLine":46,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":24,"originalLine":46,"originalColumn":14,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":46,"originalLine":46,"originalColumn":37,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":60,"originalLine":47,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":95,"originalLine":48,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":122,"originalLine":48,"originalColumn":25,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":144,"originalLine":48,"originalColumn":48,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":151,"originalLine":49,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":24,"generatedColumn":181,"originalLine":49,"originalColumn":29,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":25,"generatedColumn":4,"originalLine":49,"originalColumn":29,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":25,"generatedColumn":4,"originalLine":49,"originalColumn":65,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":25,"generatedColumn":49,"originalLine":49,"originalColumn":111,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":26,"generatedColumn":4,"originalLine":49,"originalColumn":111,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":26,"generatedColumn":4,"originalLine":49,"originalColumn":121,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":26,"generatedColumn":42,"originalLine":49,"originalColumn":160,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":27,"generatedColumn":4,"originalLine":49,"originalColumn":160,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":27,"generatedColumn":4,"originalLine":49,"originalColumn":165,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":27,"generatedColumn":12,"originalLine":49,"originalColumn":171,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":27,"generatedColumn":32,"originalLine":49,"originalColumn":192,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":27,"generatedColumn":35,"originalLine":49,"originalColumn":193,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":27,"generatedColumn":50,"originalLine":49,"originalColumn":209,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":27,"generatedColumn":75,"originalLine":49,"originalColumn":232,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":28,"generatedColumn":4,"originalLine":49,"originalColumn":232,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":28,"generatedColumn":4,"originalLine":49,"originalColumn":264,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":28,"generatedColumn":11,"originalLine":49,"originalColumn":268,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":28,"generatedColumn":36,"originalLine":49,"originalColumn":294,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":28,"generatedColumn":40,"originalLine":49,"originalColumn":295,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":4,"originalLine":49,"originalColumn":295,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":4,"originalLine":49,"originalColumn":300,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":9,"originalLine":50,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":41,"originalLine":50,"originalColumn":31,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":87,"originalLine":50,"originalColumn":78,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":92,"originalLine":51,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":119,"originalLine":51,"originalColumn":26,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":159,"originalLine":51,"originalColumn":67,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":164,"originalLine":52,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":186,"originalLine":53,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":220,"originalLine":54,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":29,"generatedColumn":247,"originalLine":54,"originalColumn":26,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":30,"generatedColumn":4,"originalLine":54,"originalColumn":26,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":30,"generatedColumn":4,"originalLine":54,"originalColumn":62,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":30,"generatedColumn":49,"originalLine":54,"originalColumn":108,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":31,"generatedColumn":4,"originalLine":54,"originalColumn":108,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":31,"generatedColumn":4,"originalLine":54,"originalColumn":118,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":31,"generatedColumn":42,"originalLine":54,"originalColumn":157,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":4,"originalLine":54,"originalColumn":157,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":4,"originalLine":54,"originalColumn":162,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":8,"originalLine":54,"originalColumn":164,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":28,"originalLine":54,"originalColumn":185,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":31,"originalLine":54,"originalColumn":186,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":46,"originalLine":54,"originalColumn":202,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":62,"originalLine":54,"originalColumn":215,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":84,"originalLine":54,"originalColumn":238,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":92,"originalLine":55,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":130,"originalLine":56,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":32,"generatedColumn":148,"originalLine":56,"originalColumn":17,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":33,"generatedColumn":4,"originalLine":56,"originalColumn":17,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":33,"generatedColumn":4,"originalLine":56,"originalColumn":58,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":33,"generatedColumn":8,"originalLine":57,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":33,"generatedColumn":28,"originalLine":57,"originalColumn":19,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":34,"generatedColumn":4,"originalLine":57,"originalColumn":19,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":34,"generatedColumn":4,"originalLine":57,"originalColumn":78,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":34,"generatedColumn":8,"originalLine":58,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":34,"generatedColumn":40,"originalLine":58,"originalColumn":31,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":34,"generatedColumn":61,"originalLine":58,"originalColumn":53,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":34,"generatedColumn":81,"originalLine":59,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":34,"generatedColumn":101,"originalLine":59,"originalColumn":19,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":35,"generatedColumn":4,"originalLine":59,"originalColumn":19,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":35,"generatedColumn":4,"originalLine":59,"originalColumn":26,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":35,"generatedColumn":8,"originalLine":60,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":35,"generatedColumn":47,"originalLine":61,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":35,"generatedColumn":65,"originalLine":61,"originalColumn":17,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":36,"generatedColumn":4,"originalLine":61,"originalColumn":17,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":36,"generatedColumn":4,"originalLine":61,"originalColumn":65,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":36,"generatedColumn":8,"originalLine":62,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":36,"generatedColumn":48,"originalLine":63,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":36,"generatedColumn":66,"originalLine":63,"originalColumn":17,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":37,"generatedColumn":4,"originalLine":63,"originalColumn":17,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":37,"generatedColumn":4,"originalLine":63,"originalColumn":24,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":37,"generatedColumn":8,"originalLine":64,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":37,"generatedColumn":29,"originalLine":65,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":37,"generatedColumn":43,"originalLine":65,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":38,"generatedColumn":4,"originalLine":65,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":38,"generatedColumn":4,"originalLine":66,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":39,"generatedColumn":4,"originalLine":66,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":39,"generatedColumn":4,"originalLine":67,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":40,"generatedColumn":4,"originalLine":67,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":40,"generatedColumn":4,"originalLine":67,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":40,"generatedColumn":8,"originalLine":68,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":40,"generatedColumn":20,"originalLine":69,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":40,"generatedColumn":40,"originalLine":70,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":40,"generatedColumn":50,"originalLine":70,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":41,"generatedColumn":4,"originalLine":70,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":41,"generatedColumn":4,"originalLine":71,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":42,"generatedColumn":4,"originalLine":71,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":42,"generatedColumn":4,"originalLine":72,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":4,"originalLine":72,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":4,"originalLine":72,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":8,"originalLine":73,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":60,"originalLine":74,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":89,"originalLine":75,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":139,"originalLine":75,"originalColumn":48,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":155,"originalLine":75,"originalColumn":65,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":162,"originalLine":76,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":241,"originalLine":77,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":268,"originalLine":77,"originalColumn":25,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":288,"originalLine":77,"originalColumn":46,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":291,"originalLine":77,"originalColumn":47,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":306,"originalLine":77,"originalColumn":63,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":313,"originalLine":78,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":353,"originalLine":79,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":381,"originalLine":80,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":410,"originalLine":81,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":439,"originalLine":82,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":459,"originalLine":83,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":492,"originalLine":84,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":544,"originalLine":85,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":615,"originalLine":86,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":675,"originalLine":87,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":745,"originalLine":87,"originalColumn":66,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":765,"originalLine":87,"originalColumn":87,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":768,"originalLine":87,"originalColumn":88,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":783,"originalLine":87,"originalColumn":104,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":801,"originalLine":88,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":833,"originalLine":89,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":858,"originalLine":90,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":862,"originalLine":91,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":905,"originalLine":92,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":948,"originalLine":93,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":984,"originalLine":94,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1014,"originalLine":95,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1051,"originalLine":96,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1074,"originalLine":97,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1095,"originalLine":98,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1115,"originalLine":99,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1146,"originalLine":100,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1193,"originalLine":100,"originalColumn":46,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1213,"originalLine":100,"originalColumn":67,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1216,"originalLine":100,"originalColumn":68,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1231,"originalLine":100,"originalColumn":84,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1235,"originalLine":100,"originalColumn":86,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1251,"originalLine":100,"originalColumn":103,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1262,"originalLine":101,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1282,"originalLine":102,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1299,"originalLine":103,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1315,"originalLine":104,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":43,"generatedColumn":1327,"originalLine":104,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":44,"generatedColumn":4,"originalLine":104,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":44,"generatedColumn":4,"originalLine":105,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":45,"generatedColumn":4,"originalLine":105,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":45,"generatedColumn":4,"originalLine":106,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":46,"generatedColumn":4,"originalLine":106,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":46,"generatedColumn":4,"originalLine":107,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":4,"originalLine":107,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":4,"originalLine":107,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":8,"originalLine":108,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":30,"originalLine":108,"originalColumn":20,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":44,"originalLine":108,"originalColumn":35,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":84,"originalLine":109,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":131,"originalLine":110,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":168,"originalLine":111,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":261,"originalLine":111,"originalColumn":92,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":281,"originalLine":111,"originalColumn":113,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":284,"originalLine":111,"originalColumn":114,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":299,"originalLine":111,"originalColumn":130,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":316,"originalLine":111,"originalColumn":145,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":330,"originalLine":111,"originalColumn":160,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":357,"originalLine":112,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":395,"originalLine":113,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":438,"originalLine":114,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":483,"originalLine":115,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":502,"originalLine":116,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":558,"originalLine":117,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":601,"originalLine":118,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":653,"originalLine":119,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":738,"originalLine":119,"originalColumn":83,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":758,"originalLine":119,"originalColumn":104,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":761,"originalLine":119,"originalColumn":105,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":776,"originalLine":119,"originalColumn":121,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":784,"originalLine":120,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":832,"originalLine":121,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":864,"originalLine":121,"originalColumn":30,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":878,"originalLine":121,"originalColumn":45,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":903,"originalLine":122,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":924,"originalLine":123,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":945,"originalLine":124,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":962,"originalLine":125,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":978,"originalLine":126,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":47,"generatedColumn":990,"originalLine":126,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":48,"generatedColumn":4,"originalLine":126,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":48,"generatedColumn":4,"originalLine":126,"originalColumn":16,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":48,"generatedColumn":8,"originalLine":127,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":48,"generatedColumn":18,"originalLine":127,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":49,"generatedColumn":4,"originalLine":127,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":49,"generatedColumn":4,"originalLine":127,"originalColumn":14,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":49,"generatedColumn":8,"originalLine":128,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":49,"generatedColumn":18,"originalLine":128,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":50,"generatedColumn":4,"originalLine":128,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":50,"generatedColumn":4,"originalLine":129,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":51,"generatedColumn":4,"originalLine":129,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":51,"generatedColumn":4,"originalLine":130,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":52,"generatedColumn":4,"originalLine":130,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":52,"generatedColumn":4,"originalLine":131,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":53,"generatedColumn":4,"originalLine":131,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":53,"generatedColumn":4,"originalLine":131,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":53,"generatedColumn":8,"originalLine":132,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":53,"generatedColumn":20,"originalLine":132,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":54,"generatedColumn":4,"originalLine":132,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":54,"generatedColumn":4,"originalLine":132,"originalColumn":38,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":54,"generatedColumn":9,"originalLine":132,"originalColumn":41,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":54,"generatedColumn":27,"originalLine":132,"originalColumn":60,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":54,"generatedColumn":32,"originalLine":132,"originalColumn":63,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":55,"generatedColumn":4,"originalLine":132,"originalColumn":63,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":55,"generatedColumn":4,"originalLine":132,"originalColumn":68,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":55,"generatedColumn":8,"originalLine":133,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":55,"generatedColumn":22,"originalLine":133,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":55,"generatedColumn":37,"originalLine":133,"originalColumn":29,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":55,"generatedColumn":50,"originalLine":133,"originalColumn":40,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":56,"generatedColumn":4,"originalLine":133,"originalColumn":40,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":56,"generatedColumn":4,"originalLine":133,"originalColumn":64,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":56,"generatedColumn":21,"originalLine":133,"originalColumn":82,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":4,"originalLine":133,"originalColumn":82,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":4,"originalLine":133,"originalColumn":87,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":10,"originalLine":134,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":97,"originalLine":134,"originalColumn":86,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":117,"originalLine":134,"originalColumn":107,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":120,"originalLine":134,"originalColumn":108,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":135,"originalLine":134,"originalColumn":124,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":153,"originalLine":134,"originalColumn":140,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":168,"originalLine":134,"originalColumn":156,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":186,"originalLine":134,"originalColumn":172,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":201,"originalLine":134,"originalColumn":188,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":210,"originalLine":135,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":226,"originalLine":135,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"expression","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":241,"originalLine":135,"originalColumn":31,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":245,"originalLine":136,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":263,"originalLine":137,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":57,"generatedColumn":273,"originalLine":137,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":58,"generatedColumn":4,"originalLine":137,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":58,"generatedColumn":4,"originalLine":138,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":59,"generatedColumn":4,"originalLine":138,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"code","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":59,"generatedColumn":4,"originalLine":138,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":59,"generatedColumn":8,"originalLine":139,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":59,"generatedColumn":19,"originalLine":140,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":59,"generatedColumn":28,"originalLine":141,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"},{"generatedLine":59,"generatedColumn":35,"originalLine":142,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.view-thing.metaclientmethods.njs.js","name":"text","content":"<#@ noContent #>\n<#\n  const _ = require('lodash')\n  let clMeth = context.clientMethods ?? []\n  let localStateMachine = context.stateMachine;\n#>\n\n\n// TODO:\n// исправить методы для работы с состояниями, и сделать их правильными...\n// нужно передавать название события, а перевод состояния тоже делать, но отдельно\n// форма должна отображать события, и текущее состояние, которое должно меняться, по методу\n// перенести stateMachine на клиента\nExt.define('Grainjs.metaclientmethods.#{context.$namespace}.#{context.$name}', {\n  override: 'Grainjs.metadata',\n  statics:{\n    'metaclientmethods.#{context.$namespace}.#{context.$name}': {\n      buttons: {\n      <#if (localStateMachine && context.debugSM) { #>\n        <# for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n            let ev = localStateMachine.event[i]\n        #>\n        \"btn_#{ev.eventName}\": () => ({\n          xtype: \"button\",\n          itemId: \"#{ev.eventName}\",\n          iconCls: _r(\"#{ev.eventName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\", \"iconCls\"),\n          columnWidth: void 0,\n          _order: 0,\n          //\n          minWidth: 160,\n          text: _r(\"#{ev.eventName}\", \"#{ev.displayName}\", \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\"),\n          textAlign: \"left\",\n          toggleGroup: \"state\",\n          name: '#{ev.eventName}',\n          disabled: true,\n          pressed: false,\n          enableToggle: true\n        }),\n        <#}#>\n      <#}#>\n        <#\n          const buttons = clMeth.filter(m=> (m.type == 'toggle' || m.type == 'button') && !m.disabled);\n          for (let i = 0; i < buttons.length; i++) {\n            let clientMethodCur = buttons[i];\n            #>\n            \"#{clientMethodCur.name}\": ()=>({\n                xtype:'button',\n                itemId:\"#{clientMethodCur.name}\",\n                iconCls: _r(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'', '#{context.$namespace}.#{context.$name}', 'methods','iconCls')<#if(clientMethodCur.iconCls){#>||\" #{clientMethodCur.iconCls}\"<#}#>,\n                columnWidth:  #{clientMethodCur.currentSettings?.columnWidth},\n                _order:  #{clientMethodCur.currentSettings?.order},\n                //\n                minWidth: 160,\n                text: _t(<#if(clientMethodCur.displayName){#>#{JSON.stringify(clientMethodCur.displayName)}<#}else{#>#{JSON.stringify(clientMethodCur.name)}<#}#>,'#{context.$namespace}.#{context.$name}','buttons',\"#{clientMethodCur.name}\"),\n                textAlign: 'left',\n                <#- if(clientMethodCur.type=='toggle'){#>\n                  <#- if(!clientMethodCur.currentSettings?.showInsideForm){#>\n                toggleGroup: '#{context.$widgetName}FormNavigation',\n                  <#- }#>\n                enableToggle: true,\n                <#- } else if(clientMethodCur.type=='button'){#>\n                enableToggle: false,\n                <#- }#>\n              }),\n            <#\n          }\n        #>\n      },\n      methods: {\n        <#if (localStateMachine) {\n          const stateAttribute = localStateMachine.stateAttribute\n        #>\n          _initstates: function (record, form) {\n            if (record) {\n              const currentState = record.get(\"#{stateAttribute}\")\n              ret = Promisify.direct(StoredQuery, \"getAvailableEvents\", {\n                thing: \"#{context.$namespace}.#{context.$name}\",\n                state: currentState,\n                page: 1,\n                start: 0,\n                limit: 25\n              })\n              .then(data => {\n                const wnd = form.up(\"window\");\n                const list = wnd.query('button[toggleGroup=state]')\n                const states = data.reduce((ret, cur)=>{\n                  ret[cur.key] = _t(cur.value, \"StateMachines\", \"#{context.$namespace}.#{context.$name}\", \"state\")\n                  return ret\n                },{})\n\n                for(const btn of list){\n                  if(states[btn.name]){\n                    btn.enable()\n                  } else {\n                    btn.disable()\n                  }\n                }\n              })\n              .catch(e => {\n                console.log('_initstates for #{context.$namespace}.#{context.$name}: #{stateAttribute} ->',e)\n              })\n            }\n          },\n          <#\n            for (let i = localStateMachine.event.length - 1; i >= 0; i--) {\n              let ev = localStateMachine.event[i]\n          #>\n          \"execute_#{ev.eventName}\": function (btn, pressed, eOpts) {\n            const wnd = btn.up(\"window\");\n            if (wnd && pressed) {\n              DirectCacheLogger.userStories('State Machine Event Execute', { serverModel: '#{context.$namespace}.#{context.$name}', eventName: '#{ev.eventName}', windowId: wnd.id });\n              const rec = wnd.rec;\n              if (!rec.changingState) {\n                rec.changingState = true;\n              }\n              wnd.fireEvent(\"commitrecord\", wnd, {\n                callback: function () {\n                  wnd.zIndexManager.getActive();\n                  var ctrl = wnd.modeleditorController.application.getController(\"#{context.$namespace}.#{context.$name}\");\n                  rec.changingState = false;\n                  ctrl[\"fire_#{ev.eventName}\"](wnd.down(), rec);\n                }\n              });\n            }\n          },\n          <#}#>\n        <#}#>\n        <#-  const methods = clMeth.filter(m=> m.type != 'model' && m.type != 'constructor' && !m.disabled);\n        for (let i = 0; i < methods.length; i++) {\n          const clMethod = methods[i]\n          #>\n          <#- if(clMethod.comment){#>/* #{clMethod.comment} */<#}#>\n            #{clMethod.name}: function(<#if(clMethod.params){#>#{clMethod.params}<#}#>){\n              DirectCacheLogger.userStories('Custom Method Execute', { serverModel: '#{context.$namespace}.#{context.$name}', methodName: '#{clMethod.name}', methodType: '#{clMethod.type}' });\n              #{clMethod.body}\n            },\n        <#- }\n        #>\n      }\n    }\n  }\n})\n"}]}}