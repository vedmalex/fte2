{"version":3,"sources":["generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"],"names":["text","code","expression"],"mappings":"AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAiBA,IAChBC;AADD,IACCA,AACAA;AAFD,IAECA,AACAA;AAHD,IAGCA,AACAA;AAJD,IAICA,AACAA;AALD,IAKCA,AACAA;AAND,IAMCA,AAAED,IACFA,uCAAqCE,oBAAqBF,GAACE,eAAgBF,QAC3EA,qCACAA,iBACAA,oBAAkBE,oBAAqBF,GAACE,eAAgBF,QACxDA,qBACAA,UAAQC;AAZT,IAYSA,AACRA;AAbD,IAaCA,AACAA;AAdD,IAcCA,AACAA;AAfD,IAeCA,AACAA;AAhBD,IAgBCA,AACAA;AAjBD,IAiBCA,AACAA;AAlBD,IAkBCA,AACAA;AAnBD,IAmBCA,AACAA;AApBD,IAoBCA,AACAA;AArBD,IAqBCA,AACAA;AAtBD,IAsBCA,AACAA;AAvBD,IAuBCA,AAAYD,IACZA,cAAYE,uBAAwBF,IAAEE,cAAeF,cACrDA,0BAAuBE,uBAAwBF,OAC/CA,4BAA0BE,8BAA+BF,IAAEE,oBAAqBF,GAACE,eAAgBF,cAAYE,uBAAwBF,OACrIA,yBAAuBE,QAASF,GAACC;AA3BlC,IA2BkCA,AAA8BD,IAC/DA,wBAAsBE,SAAUF,GAACC;AA5BlC,IA4BkCA,AAAKD,IACtCA,2BAAyBE,UAAWF,KACpCA,2BAAyBE,2CAA4CF,KACrEA,cAAYC;AA/Bb,IA+BaA,AAAqBD,IACjCA,uBACAA,cAAYC;AAjCb,IAiCaA,AAAyDD,IACrEA,cAAYC;AAlCb,IAkCaA,AACZA;AAnCD,IAmCCA,AAA+DD,KAC/DA,gCACAA,gBAAcC;AArCf,IAqCeA,AAA4BD,IAC1CA,qDAAmDE,oBAAqBF,GAACE,eAAgBF,KAAGE,uCAAwCF,MACpIA,gBAAcC;AAvCf,IAuCeA,AAAYD,IAC1BA,mDAAiDE,oBAAqBF,GAACE,eAAgBF,kBAAgBE,uCAAwCF,cAC/IA,gBAAcC;AAzCf,IAyCeA,AAAKD,IACnBA,2DAAyDE,oBAAqBF,GAACE,eAAgBF,kBAAgBE,uCAAwCF,mBACvJA,yDAAuDE,oBAAqBF,GAACE,eAAgBF,kBAAgBE,uCAAwCF,gBACrJA,iBACAA,cAAYC;AA7Cb,IA6CaA,AAAiED,IAC7EA,yBACAA,cAAYC;AA/Cb,IA+CaA,AAA0CD,IACtDA,gBAAcE,2BAA4BF,IAC1CA,cAAYC;AAjDb,IAiDaA,AACZA;AAlDD,IAkDCA,AAAsBD,OAAKC;AAlD5B,IAkD4BA,AAAKD,IAChCA,cAAYC;AAnDb,IAmDaA,AAAyCD,IACrDA,uBACAA,cAAYC;AArDb,IAqDaA,AAA8CD,IAC1DA,oBACAA,cAAYC;AAvDb,IAuDaA,AAAKD,IACjBA,iBACAA,cAAYC;AAzDb,IAyDaA,AAAKD,IACjBA,4BAA0BE,YAAaF,KACvCA,4BAA0BE,YAAaF,KACvCA,4BAA0BE,aAAcF,KACxCA,4BAA0BE,cAAeF,KACzCA,4BAA0BE,gBAAiBF,KAC3CA,2BAAyBE,cAAeF,KACxCA,4BAAyBE,cAAeF,IAACC;AAhE1C,IAgE0CA,AACzCA;AAjED,IAiECA,AAAkED,KAClEA,cAAYC;AAlEb,IAkEaA,AAA4BD,IACxCA,yDAAuDE,oBAAqBF,GAACE,eAAgBF,KAAGE,uCAAwCF,MACxIA,cAAYC;AApEb,IAoEaA,AAAYD,IACxBA,0DAAwDE,oBAAqBF,GAACE,eAAgBF,kBAAgBE,uCAAwCF,cACtJA,cAAYC;AAtEb,IAsEaA,AAAKD,IACjBA,+CACAA,kCACAA,0DAAwDE,oBAAqBF,GAACE,eAAgBF,kBAAgBE,uCAAwCF,MACtJA,uEACAA,8GACAA,qDACAA,4CACAA,mDACAA,8CACAA,6DACAA,0CACAA,sBACAA,mBACAA,gFACAA,oCACAA,yDACAA,uDACAA,mBACAA,6BACAA,eAAaC;AA1Fd,IA0FcA,AACbA;AA3FD,IA2FCA,AAAuED,KACvEA,6CACAA,wHAAoHE,cAAeF,OACnIA,mBACAA,cAAYC;AA/Fb,IA+FaA,AACZA;AAhGD,IAgGCA,AAAmCD,KACnCA,2CACAA,gBAAcE,kBAAmBF,IACjCA,eAAaC;AAnGd,IAmGcA,AACbA;AApGD,IAoGCA,AACAA;AArGD,IAqGCA,AAAwFD,KACxFA,wCACAA,4DACAA,wCACAA,mCACAA,4CACAA,IACAA,wDACAA,qCACAA,kCACAA,0CACAA,mEACAA,qCACAA,kCACAA,0CACAA,qBACAA,IACAA,kCACAA,qCACAA,uDACAA,+BACAA,iCACAA,wDACAA,gDACAA,qDACAA,wDACAA,gDACAA,0DACAA,2CACAA,4DACAA,8DACAA,uDACAA,kCACAA,iCACAA,8BACAA,4BACAA,iCACAA,qBACAA,mBACAA,cAAYC;AA5Ib,IA4IaA,AAAOD,IACnBA,YAAUC;AA7IX,IA6IWA,AAAiDD,MAAIE,gBAAiBF,GAACC;AA7IlF,IA6IkFA,AAAKD,IACtFA,iBACAA,gBAAcC;AA/If,IA+IeA,AACdA;AAhJD,IAgJCA,AACAA;AAjJD,IAiJCA,AACAA;AAlJD,IAkJCA,AAAUD,IACVA,WACAA,SACAA,OACAA,MACAA,IACAA,IACAA;AAzJD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","file":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","sourceRoot":"/Users/vedmalex/work/fte2/demo","sourcesContent":["<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"],"template":{"version":"1.0.0","segments":[{"generatedLine":1,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":2,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":3,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":4,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":5,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":6,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":7,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":8,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":9,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":10,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":11,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":12,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":13,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":14,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":15,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":16,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":17,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":18,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":19,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":20,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":21,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":22,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":23,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":24,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":25,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":26,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":27,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":28,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":29,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":30,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":31,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":32,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":33,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":34,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":35,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":36,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":37,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":38,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":39,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":40,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":41,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":42,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":43,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":44,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":45,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":46,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":47,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":48,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":49,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":50,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":51,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":52,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":53,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":54,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":55,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":56,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":57,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":58,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":59,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":60,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":61,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":62,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":63,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":64,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":65,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":66,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":67,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":68,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":69,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":70,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":71,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":72,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":73,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":74,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":75,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":76,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":77,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":78,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":79,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":80,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":81,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":82,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":83,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":84,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":85,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":86,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":87,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":88,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":89,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":90,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":91,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":92,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":93,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":94,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":95,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":96,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":97,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":98,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":99,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":100,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":101,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":102,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":103,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":104,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":105,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":106,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":107,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":108,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":109,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":110,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":111,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":112,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":113,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":114,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":115,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":116,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":117,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":118,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":119,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":120,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":121,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":122,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":123,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":124,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":125,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":126,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":127,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":128,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":129,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":130,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":131,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":132,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":133,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":134,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":135,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":136,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":137,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":138,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":139,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":140,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":141,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":142,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":143,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":144,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":145,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":146,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":147,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":148,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":149,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":150,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":151,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":152,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":153,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":154,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":155,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":156,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":157,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":158,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":159,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":160,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":161,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":162,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":163,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":164,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":165,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":166,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":167,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":168,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":169,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":170,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":171,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":172,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":173,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":174,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":175,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":176,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":177,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":178,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":179,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":180,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":181,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":182,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":183,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":184,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":185,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":186,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":187,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":188,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":189,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":190,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":191,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":192,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":193,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":194,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":195,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":196,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":197,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":198,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":199,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":200,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":201,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":202,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":203,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":204,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":205,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":206,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":207,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":208,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":209,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":210,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":211,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":212,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":213,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":214,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":215,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":216,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":217,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":218,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":219,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":220,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":221,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":222,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":223,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":224,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":225,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":226,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":227,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js"},{"generatedLine":8,"generatedColumn":4,"originalLine":1,"originalColumn":17,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":8,"generatedColumn":8,"originalLine":2,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":9,"generatedColumn":4,"originalLine":2,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":9,"generatedColumn":4,"originalLine":3,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":10,"generatedColumn":4,"originalLine":3,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":10,"generatedColumn":4,"originalLine":4,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":11,"generatedColumn":4,"originalLine":4,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":11,"generatedColumn":4,"originalLine":5,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":12,"generatedColumn":4,"originalLine":5,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":12,"generatedColumn":4,"originalLine":6,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":13,"generatedColumn":4,"originalLine":6,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":13,"generatedColumn":4,"originalLine":7,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":4,"originalLine":7,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":4,"originalLine":7,"originalColumn":3,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":8,"originalLine":8,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":47,"originalLine":8,"originalColumn":38,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":67,"originalLine":8,"originalColumn":59,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":70,"originalLine":8,"originalColumn":60,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":85,"originalLine":8,"originalColumn":76,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":93,"originalLine":9,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":130,"originalLine":10,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":147,"originalLine":11,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":167,"originalLine":11,"originalColumn":19,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":187,"originalLine":11,"originalColumn":40,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":190,"originalLine":11,"originalColumn":41,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":205,"originalLine":11,"originalColumn":57,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":213,"originalLine":12,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":234,"originalLine":13,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":14,"generatedColumn":244,"originalLine":13,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":15,"generatedColumn":4,"originalLine":13,"originalColumn":9,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":15,"generatedColumn":4,"originalLine":14,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":16,"generatedColumn":4,"originalLine":14,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":16,"generatedColumn":4,"originalLine":15,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":17,"generatedColumn":4,"originalLine":15,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":17,"generatedColumn":4,"originalLine":16,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":18,"generatedColumn":4,"originalLine":16,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":18,"generatedColumn":4,"originalLine":17,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":19,"generatedColumn":4,"originalLine":17,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":19,"generatedColumn":4,"originalLine":18,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":20,"generatedColumn":4,"originalLine":18,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":20,"generatedColumn":4,"originalLine":19,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":21,"generatedColumn":4,"originalLine":19,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":21,"generatedColumn":4,"originalLine":20,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":22,"generatedColumn":4,"originalLine":20,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":22,"generatedColumn":4,"originalLine":21,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":23,"generatedColumn":4,"originalLine":21,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":23,"generatedColumn":4,"originalLine":22,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":24,"generatedColumn":4,"originalLine":22,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":24,"generatedColumn":4,"originalLine":23,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":25,"generatedColumn":4,"originalLine":23,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":25,"generatedColumn":4,"originalLine":24,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":4,"originalLine":24,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":4,"originalLine":24,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":8,"originalLine":25,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":22,"originalLine":25,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":45,"originalLine":25,"originalColumn":37,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":49,"originalLine":25,"originalColumn":39,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":63,"originalLine":25,"originalColumn":54,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":77,"originalLine":26,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":103,"originalLine":26,"originalColumn":24,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":126,"originalLine":26,"originalColumn":48,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":133,"originalLine":27,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":161,"originalLine":27,"originalColumn":27,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":191,"originalLine":27,"originalColumn":58,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":195,"originalLine":27,"originalColumn":60,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":215,"originalLine":27,"originalColumn":81,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":218,"originalLine":27,"originalColumn":82,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":233,"originalLine":27,"originalColumn":98,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":247,"originalLine":27,"originalColumn":110,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":270,"originalLine":27,"originalColumn":134,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":277,"originalLine":28,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":302,"originalLine":28,"originalColumn":24,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":310,"originalLine":28,"originalColumn":33,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":26,"generatedColumn":313,"originalLine":28,"originalColumn":34,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":27,"generatedColumn":4,"originalLine":28,"originalColumn":34,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":27,"generatedColumn":4,"originalLine":28,"originalColumn":64,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":27,"generatedColumn":8,"originalLine":29,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":27,"generatedColumn":32,"originalLine":29,"originalColumn":23,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":27,"generatedColumn":41,"originalLine":29,"originalColumn":33,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":27,"generatedColumn":44,"originalLine":29,"originalColumn":34,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":28,"generatedColumn":4,"originalLine":29,"originalColumn":34,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":28,"generatedColumn":4,"originalLine":29,"originalColumn":39,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":28,"generatedColumn":8,"originalLine":30,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":28,"generatedColumn":35,"originalLine":30,"originalColumn":26,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":28,"generatedColumn":45,"originalLine":30,"originalColumn":37,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":28,"generatedColumn":50,"originalLine":31,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":28,"generatedColumn":77,"originalLine":31,"originalColumn":26,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":28,"generatedColumn":120,"originalLine":31,"originalColumn":70,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":28,"generatedColumn":125,"originalLine":32,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":28,"generatedColumn":139,"originalLine":32,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":29,"generatedColumn":4,"originalLine":32,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":29,"generatedColumn":4,"originalLine":32,"originalColumn":34,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":29,"generatedColumn":8,"originalLine":33,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":29,"generatedColumn":31,"originalLine":34,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":29,"generatedColumn":45,"originalLine":34,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":30,"generatedColumn":4,"originalLine":34,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":30,"generatedColumn":4,"originalLine":34,"originalColumn":70,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":30,"generatedColumn":8,"originalLine":35,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":30,"generatedColumn":22,"originalLine":35,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":31,"generatedColumn":4,"originalLine":35,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":31,"generatedColumn":4,"originalLine":36,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":32,"generatedColumn":4,"originalLine":36,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":32,"generatedColumn":4,"originalLine":36,"originalColumn":64,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":32,"generatedColumn":9,"originalLine":37,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":32,"generatedColumn":41,"originalLine":38,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":32,"generatedColumn":57,"originalLine":38,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":4,"originalLine":38,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":4,"originalLine":38,"originalColumn":43,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":8,"originalLine":39,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":61,"originalLine":39,"originalColumn":52,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":81,"originalLine":39,"originalColumn":73,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":84,"originalLine":39,"originalColumn":74,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":99,"originalLine":39,"originalColumn":90,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":104,"originalLine":39,"originalColumn":93,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":143,"originalLine":39,"originalColumn":133,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":149,"originalLine":40,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":33,"generatedColumn":165,"originalLine":40,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":4,"originalLine":40,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":4,"originalLine":40,"originalColumn":27,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":8,"originalLine":41,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":59,"originalLine":41,"originalColumn":50,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":79,"originalLine":41,"originalColumn":71,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":82,"originalLine":41,"originalColumn":72,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":97,"originalLine":41,"originalColumn":88,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":115,"originalLine":41,"originalColumn":104,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":154,"originalLine":41,"originalColumn":144,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":168,"originalLine":42,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":34,"generatedColumn":184,"originalLine":42,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":4,"originalLine":42,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":4,"originalLine":42,"originalColumn":20,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":8,"originalLine":43,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":67,"originalLine":43,"originalColumn":58,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":87,"originalLine":43,"originalColumn":79,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":90,"originalLine":43,"originalColumn":80,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":105,"originalLine":43,"originalColumn":96,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":123,"originalLine":43,"originalColumn":112,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":162,"originalLine":43,"originalColumn":152,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":181,"originalLine":44,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":238,"originalLine":44,"originalColumn":56,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":258,"originalLine":44,"originalColumn":77,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":261,"originalLine":44,"originalColumn":78,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":276,"originalLine":44,"originalColumn":94,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":294,"originalLine":44,"originalColumn":110,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":333,"originalLine":44,"originalColumn":150,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":349,"originalLine":45,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":366,"originalLine":46,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":35,"generatedColumn":380,"originalLine":46,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":36,"generatedColumn":4,"originalLine":46,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":36,"generatedColumn":4,"originalLine":46,"originalColumn":78,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":36,"generatedColumn":8,"originalLine":47,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":36,"generatedColumn":33,"originalLine":48,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":36,"generatedColumn":47,"originalLine":48,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":37,"generatedColumn":4,"originalLine":48,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":37,"generatedColumn":4,"originalLine":48,"originalColumn":55,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":37,"generatedColumn":8,"originalLine":49,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":37,"generatedColumn":24,"originalLine":49,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":37,"generatedColumn":51,"originalLine":49,"originalColumn":43,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":37,"generatedColumn":55,"originalLine":50,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":37,"generatedColumn":69,"originalLine":50,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":38,"generatedColumn":4,"originalLine":50,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":38,"generatedColumn":4,"originalLine":51,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":39,"generatedColumn":4,"originalLine":51,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":39,"generatedColumn":4,"originalLine":51,"originalColumn":23,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":39,"generatedColumn":11,"originalLine":51,"originalColumn":28,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":40,"generatedColumn":4,"originalLine":51,"originalColumn":28,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":40,"generatedColumn":4,"originalLine":51,"originalColumn":33,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":40,"generatedColumn":8,"originalLine":52,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":40,"generatedColumn":22,"originalLine":52,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":41,"generatedColumn":4,"originalLine":52,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":41,"generatedColumn":4,"originalLine":52,"originalColumn":54,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":41,"generatedColumn":8,"originalLine":53,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":41,"generatedColumn":31,"originalLine":54,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":41,"generatedColumn":45,"originalLine":54,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":42,"generatedColumn":4,"originalLine":54,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":42,"generatedColumn":4,"originalLine":54,"originalColumn":59,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":42,"generatedColumn":8,"originalLine":55,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":42,"generatedColumn":28,"originalLine":56,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":42,"generatedColumn":42,"originalLine":56,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":43,"generatedColumn":4,"originalLine":56,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":43,"generatedColumn":4,"originalLine":56,"originalColumn":18,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":43,"generatedColumn":8,"originalLine":57,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":43,"generatedColumn":25,"originalLine":58,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":43,"generatedColumn":39,"originalLine":58,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":4,"originalLine":58,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":4,"originalLine":58,"originalColumn":18,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":8,"originalLine":59,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":36,"originalLine":59,"originalColumn":27,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":48,"originalLine":59,"originalColumn":40,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":53,"originalLine":60,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":81,"originalLine":60,"originalColumn":27,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":93,"originalLine":60,"originalColumn":40,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":98,"originalLine":61,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":126,"originalLine":61,"originalColumn":27,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":139,"originalLine":61,"originalColumn":41,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":144,"originalLine":62,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":172,"originalLine":62,"originalColumn":27,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":186,"originalLine":62,"originalColumn":42,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":191,"originalLine":63,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":219,"originalLine":63,"originalColumn":27,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":235,"originalLine":63,"originalColumn":44,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":240,"originalLine":64,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":267,"originalLine":64,"originalColumn":26,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":281,"originalLine":64,"originalColumn":41,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":286,"originalLine":65,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":314,"originalLine":65,"originalColumn":26,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":328,"originalLine":65,"originalColumn":41,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":44,"generatedColumn":332,"originalLine":65,"originalColumn":42,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":45,"generatedColumn":4,"originalLine":65,"originalColumn":42,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":45,"generatedColumn":4,"originalLine":66,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":46,"generatedColumn":4,"originalLine":66,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":46,"generatedColumn":4,"originalLine":66,"originalColumn":67,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":46,"generatedColumn":9,"originalLine":67,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":46,"generatedColumn":23,"originalLine":67,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":4,"originalLine":67,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":4,"originalLine":67,"originalColumn":41,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":8,"originalLine":68,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":65,"originalLine":68,"originalColumn":56,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":85,"originalLine":68,"originalColumn":77,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":88,"originalLine":68,"originalColumn":78,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":103,"originalLine":68,"originalColumn":94,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":108,"originalLine":68,"originalColumn":97,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":147,"originalLine":68,"originalColumn":137,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":153,"originalLine":69,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":47,"generatedColumn":167,"originalLine":69,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":4,"originalLine":69,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":4,"originalLine":69,"originalColumn":25,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":8,"originalLine":70,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":66,"originalLine":70,"originalColumn":57,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":86,"originalLine":70,"originalColumn":78,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":89,"originalLine":70,"originalColumn":79,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":104,"originalLine":70,"originalColumn":95,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":122,"originalLine":70,"originalColumn":111,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":161,"originalLine":70,"originalColumn":151,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":175,"originalLine":71,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":48,"generatedColumn":189,"originalLine":71,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":4,"originalLine":71,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":4,"originalLine":71,"originalColumn":18,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":8,"originalLine":72,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":55,"originalLine":73,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":89,"originalLine":74,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":147,"originalLine":74,"originalColumn":57,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":167,"originalLine":74,"originalColumn":78,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":170,"originalLine":74,"originalColumn":79,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":185,"originalLine":74,"originalColumn":95,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":203,"originalLine":74,"originalColumn":111,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":242,"originalLine":74,"originalColumn":151,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":248,"originalLine":75,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":319,"originalLine":76,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":429,"originalLine":77,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":482,"originalLine":78,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":526,"originalLine":79,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":577,"originalLine":80,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":623,"originalLine":81,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":684,"originalLine":82,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":726,"originalLine":83,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":748,"originalLine":84,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":767,"originalLine":85,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":847,"originalLine":86,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":883,"originalLine":87,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":940,"originalLine":88,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":995,"originalLine":89,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":1014,"originalLine":90,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":1043,"originalLine":91,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":49,"generatedColumn":1058,"originalLine":91,"originalColumn":14,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":50,"generatedColumn":4,"originalLine":91,"originalColumn":14,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":50,"generatedColumn":4,"originalLine":92,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":51,"generatedColumn":4,"originalLine":92,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":51,"generatedColumn":4,"originalLine":92,"originalColumn":72,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":51,"generatedColumn":9,"originalLine":93,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":51,"generatedColumn":54,"originalLine":94,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":51,"generatedColumn":174,"originalLine":94,"originalColumn":117,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":51,"generatedColumn":188,"originalLine":94,"originalColumn":132,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":51,"generatedColumn":195,"originalLine":95,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":51,"generatedColumn":214,"originalLine":96,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":51,"generatedColumn":228,"originalLine":96,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":52,"generatedColumn":4,"originalLine":96,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":52,"generatedColumn":4,"originalLine":97,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":53,"generatedColumn":4,"originalLine":97,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":53,"generatedColumn":4,"originalLine":97,"originalColumn":36,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":53,"generatedColumn":9,"originalLine":98,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":53,"generatedColumn":52,"originalLine":99,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":53,"generatedColumn":68,"originalLine":99,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":53,"generatedColumn":86,"originalLine":99,"originalColumn":34,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":53,"generatedColumn":90,"originalLine":100,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":53,"generatedColumn":105,"originalLine":100,"originalColumn":14,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":54,"generatedColumn":4,"originalLine":100,"originalColumn":14,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":54,"generatedColumn":4,"originalLine":101,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":55,"generatedColumn":4,"originalLine":101,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":55,"generatedColumn":4,"originalLine":102,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":4,"originalLine":102,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":4,"originalLine":102,"originalColumn":89,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":9,"originalLine":103,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":49,"originalLine":104,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":109,"originalLine":105,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":149,"originalLine":106,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":184,"originalLine":107,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":228,"originalLine":108,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":232,"originalLine":109,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":288,"originalLine":110,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":325,"originalLine":111,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":359,"originalLine":112,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":401,"originalLine":113,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":468,"originalLine":114,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":505,"originalLine":115,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":539,"originalLine":116,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":581,"originalLine":117,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":602,"originalLine":118,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":606,"originalLine":119,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":640,"originalLine":120,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":677,"originalLine":121,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":732,"originalLine":122,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":763,"originalLine":123,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":796,"originalLine":124,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":852,"originalLine":125,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":900,"originalLine":126,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":953,"originalLine":127,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1009,"originalLine":128,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1057,"originalLine":129,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1115,"originalLine":130,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1158,"originalLine":131,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1218,"originalLine":132,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1280,"originalLine":133,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1335,"originalLine":134,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1369,"originalLine":135,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1402,"originalLine":136,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1432,"originalLine":137,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1460,"originalLine":138,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1493,"originalLine":139,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1514,"originalLine":140,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1533,"originalLine":141,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":56,"generatedColumn":1547,"originalLine":141,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":57,"generatedColumn":4,"originalLine":141,"originalColumn":13,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":57,"generatedColumn":4,"originalLine":141,"originalColumn":20,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":57,"generatedColumn":8,"originalLine":142,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":57,"generatedColumn":20,"originalLine":142,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":58,"generatedColumn":4,"originalLine":142,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":58,"generatedColumn":4,"originalLine":142,"originalColumn":60,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":58,"generatedColumn":10,"originalLine":142,"originalColumn":64,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"expression","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":58,"generatedColumn":26,"originalLine":142,"originalColumn":81,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":58,"generatedColumn":29,"originalLine":142,"originalColumn":82,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":59,"generatedColumn":4,"originalLine":142,"originalColumn":82,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":59,"generatedColumn":4,"originalLine":142,"originalColumn":87,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":59,"generatedColumn":8,"originalLine":143,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":59,"generatedColumn":25,"originalLine":144,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":59,"generatedColumn":41,"originalLine":144,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":60,"generatedColumn":4,"originalLine":144,"originalColumn":15,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":60,"generatedColumn":4,"originalLine":145,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":61,"generatedColumn":4,"originalLine":145,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":61,"generatedColumn":4,"originalLine":146,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":62,"generatedColumn":4,"originalLine":146,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":62,"generatedColumn":4,"originalLine":147,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":63,"generatedColumn":4,"originalLine":147,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"code","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":63,"generatedColumn":4,"originalLine":147,"originalColumn":11,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":63,"generatedColumn":8,"originalLine":148,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":63,"generatedColumn":19,"originalLine":149,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":63,"generatedColumn":28,"originalLine":150,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":63,"generatedColumn":35,"originalLine":151,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":63,"generatedColumn":41,"originalLine":152,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":63,"generatedColumn":45,"originalLine":153,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"},{"generatedLine":63,"generatedColumn":49,"originalLine":154,"originalColumn":1,"source":"generators/server/Meta.Thing/ext.grid-thing.metagridfields.njs.js","name":"text","content":"<#@ noContent #>\n<#-\n  //Helpers for generation\n  const getFormat = context.getFormat\n\n  let properties = [...context.gridviewProps].sort((a,b)=>a.property.propertyName > b.property.propertyName? 1:-1 )\n#>\n  Ext.define('Grainjs.metagridfields.#{context.$namespace}.#{context.$name}', {\n    override: 'Grainjs.metadata',\n    statics:{\n      'gridfields.#{context.$namespace}.#{context.$name}': {\n        fields: {\n        <#-\n          for(let i=0; i<properties.length; i++){\n            let property = properties[i].property;\n            let g = properties[i]\n            const viewProps = context.formPropsHash[property.propertyName].filter(f=>f.generated)\n            let f;\n            if(viewProps.length > 0){\n              f = viewProps[0]\n            } else {\n              f = {}\n            }\n          #>\n          [`#{property.propertyName}::#{g.columnText}`]:()=> ({\n            dataIndex:\"#{property.propertyName}\",\n            text:      _t(#{JSON.stringify(g.columnText)},'#{context.$namespace}.#{context.$name}','labels','#{property.propertyName}'),\n            flex:      #{g.flex},<#if (g.width && g.width>0){#>\n            width:    #{g.width},<#}#>\n            hidden:      #{g.hidden},\n            filterable:  #{property.isVirtual ? false : g.filterable},\n            <#if(g.filterable){#>\n            filter:\n            <# if (g.enforceFilter === 'none' || !g.enforceFilter){#>\n            <#- if(!property.isVirtual){\n              if(f.fieldtype === \"combobox\" && g.filterable){#>{\n              type: 'combo',\n              <#if(f.comboForcePreload){#>\n              store: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n              <#} else {#>\n              store: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n              <#}#>\n              displayField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].displayField,\n              valueField:  Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].valueField\n            }\n            <#- } else if(!(g.filter|| g.filterable) && property.relation){#>\n              \"key\"\n            <#- } else  if(g.filter|| g.filterable){#>\n              #{(g.filter|| g.filterable)}\n            <#- }\n            } else {#>false<#}#>\n            <#} else if(g.enforceFilter === 'key'){#>\n            \"key\"\n            <#- } else if(g.enforceFilter === 'filter'){#>\n            true\n            <#}#>\n            ,\n            <#}#>\n            sortable:     #{g.sortable},\n            hideable:     #{g.hideable},\n            draggable:    #{g.draggable},\n            resizeable:   #{g.resizeable},\n            menuDisabled: #{g.menuDisabled},\n            format:      #{getFormat(g)},\n            xtype:      \"#{g.columntype}\"<#\n            if(!g.columnRenderer && f.fieldtype === \"combobox\"){#>,\n            <#if(f.comboForcePreload){#>\n            renderStore: Grainjs.metadata['renderstore.#{context.$namespace}.#{context.$name}'][#{JSON.stringify(property.propertyName)}],\n            <#} else {#>\n            // renderStore: Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}].store(),\n            <#}#>\n            renderer:  function(value, me){\n              let res = value;\n              let options = Grainjs.metadata['gridcombo.#{context.$namespace}.#{context.$name}'].comboOptions[#{JSON.stringify(property.propertyName)}];\n              let store = me.column.renderStore ?? options.store();\n              if(store?.loadState !== Ext.data.LoggedStore.STATE_LOADED && !me.column.renderStoreLoaded) {\n                const grid = me.column.up('grid')\n                const column = me.column\n                column.renderStoreLoaded = true\n                column.renderStore = store\n                Promisify.event(store, 'load').then(_=> {\n                  grid.view.refresh();\n                })\n              }\n              let index = store?.findExact(options.valueField, value) ?? -1;\n              if (index != -1) {\n                let result = store.getAt(index).data;\n                res = result[options.displayField];\n              }\n              return res;\n            }<#} else\n            if(!g.columnRenderer && g.columntype === \"numbercolumn\"){#>,\n              renderer: function(value) {\n                return Ext.String.format('<div style=\"text-align: right;\">{0}</div>', Ext.util.Format.number(value, #{getFormat(g)}));\n              }\n            <#- } else\n            if(g.columnRenderer){#>,\n            renderer:  function(value){\n              #{g.columnRenderer}\n            }<#}\n\n            if (context.periodicalRel && property.propertyName == context.titleProp) {#>,\n              xtype: \"gridcolumn\",\n              renderer: function(val, metaData, record){\n                let styling = false;\n                let txt = \"\";\n                let color = \"#E8E8E8\";\n\n                if (record.get(\"_isperiodical\")) {\n                  styling = true;\n                  txt = \"P\";\n                  color = \"#F5DEB3\";\n                } else if (record.get(\"_isperiodicalroot\")) {\n                  styling = true;\n                  txt = \"R\";\n                  color = \"#E8E8E8\";\n                }\n\n                if (styling) {\n                  return '<div>'+\n                    '<div style=\"float:left\";>' +\n                      val +\n                    '</div>'+\n                    '<div style=\"padding:1px 4px;'+\n                      ' margin:0 0 0 10px;'+\n                      ' -moz-border-radius:3px;'+\n                      ' -webkit-border-radius:3px;'+\n                      ' border-radius:3px;'+\n                      ' background-color: '+color+';'+\n                      ' float:right;>'+\n                      ' -moz-box-shadow: 0 0 2px #888;'+\n                      ' -webkit-box-shadow: 0 0 2px#888;'+\n                      ' box-shadow: 0 0 2px #888;'+\n                    '\">'+txt+\n                    '</div>'+\n                  '</div>'\n                } else {\n                  return val;\n                }\n              }\n            <#- }#>\n          <#if(g.extraOptions && g.extraOptions!== '{}'){#>,...#{g.extraOptions},<#}#>\n          }),\n              <#-\n\n          }\n        #>\n      }\n    }\n  }\n})\n\n\n\n"}]}}