module.exports = {
    script: function(context, _content, partial, slot, options) {
        var out = [];
        out.push("\n");
        out.push("let pipeline = require('pipeline.js');\n");
        out.push("let Context = require('pipeline.js').Context;\n");
        out.push("let _ = require('lodash')\n");
        out.push("\n");
        const makeRelVariants = context.makeRelVariants;
        const iterateRelGroups = context.iterateRelGroups;
        const allRels = makeRelVariants(context.relations);
        const allNonEmbedded = makeRelVariants(context.relations);
        const allSearchable = makeRelVariants(context.relations);
        const anyRel = Object.keys(allNonEmbedded).length > 0;
        out.push("\n");
        out.push("\n");
        out.push("// Default Query\n");
        out.push("if (typeof(global.CustomQuery) == 'undefined') global.CustomQuery = {};\n");
        out.push("\n");
        out.push("let ComplexQuery  = require(\"@grainjs/loaders\").ComplexQuery;\n");
        out.push("\n");
        out.push("let queryLoadRelated = function(db, prm, callback){\n");
        out.push("  let child = prm.opposite;\n");
        out.push("\n");
        out.push("  if(prm.extKeys) child.childRel = prm.extKeys;\n");
        out.push("  let rels = (prm.extKeys && typeof(prm.extKeys) === 'object') ? Object.keys(prm.extKeys) : [];\n");
        out.push("\n");
        out.push("  let q = {\n");
        out.push("    \"model\":prm.model,\n");
        out.push("    \"options\": prm.options,\n");
        out.push("    \"conditions\": prm.itemId,\n");
        out.push("    \"childRel\": [child]\n");
        out.push("  };\n");
        out.push("\n");
        out.push("  ComplexQuery.execQueryOne(db, q, function(err, data) {\n");
        out.push("    if (err) {\n");
        out.push("      callback(err)\n");
        out.push("    } else {\n");
        out.push("      const res = data ? data[prm.opposite.opposite] : []\n");
        out.push("      const total = res.length == prm.opposite.options.limit ? data.total[prm.opposite.opposite]: (prm.opposite.options.skip ?? 0) + res.length\n");
        out.push("\n");
        out.push("      callback(null,\n");
        out.push("        {\n");
        out.push("          data:res,\n");
        out.push("          total,\n");
        out.push("        },\n");
        out.push("        rels);\n");
        out.push("    }\n");
        out.push("  });\n");
        out.push("};\n");
        out.push("\n");
        out.push("const childRel = [\n");
        out.push("  ");
        iterateRelGroups(allNonEmbedded, (variant, rel, relIndex, variantIndex)=>{
            out.push("\n");
            out.push("  {\n");
            out.push("    opposite: \"" + (rel.to) + "\",\n");
            out.push("    ");
            if (variant !== '*') {
                out.push("\n");
                out.push("    relName: \"" + (rel.relName) + "\",\n");
                out.push("    propName:\"" + (rel.to) + (rel.relName.split('.').join('')) + "\",\n");
                out.push("    ");
            }
            out.push("\n");
            out.push("    model: \"" + (rel.ref.thingType) + "\",\n");
            out.push("    onlyIds: true,\n");
            out.push("  },\n");
            out.push("  ");
        });
        out.push("\n");
        out.push("]\n");
        out.push("\n");
        out.push("let queryForDetail = function(prm){\n");
        out.push("  return {\n");
        out.push("    \"model\": \"" + (context.$normalizedName) + "\",\n");
        out.push("    \"options\": prm.options,\n");
        out.push("    \"conditions\": prm.root,\n");
        out.push("    \"childRel\": childRel\n");
        out.push("  };\n");
        out.push("};\n");
        out.push("\n");
        out.push("if (typeof(global.GenericSearchQueries) == 'undefined') global.GenericSearchQueries = {};\n");
        out.push("\n");
        out.push("let queryForSearch = function(prm) {\n");
        out.push("  const params = prm.search ?? {}\n");
        out.push("  const query = {\n");
        out.push("    \"model\": \"" + (context.$normalizedName) + "\",\n");
        out.push("    options: prm.options, //{ skip:0, limit: -1 },\n");
        out.push("    conditions: params.root ?? {}\n");
        out.push("  }\n");
        out.push("\n");
        out.push("  if(prm.fields) {\n");
        out.push("    query.fields = prm.fields\n");
        out.push("  }\n");
        out.push("\n");
        out.push("  const cr = []\n");
        out.push("  ");
        iterateRelGroups(allSearchable, (variant, rel, relIndex, variantIndex)=>{
            out.push("\n");
            out.push("  if(params.root_" + (rel.to) + "){\n");
            out.push("    cr.push({\n");
            out.push("      opposite: \"" + (rel.to) + "\",\n");
            out.push("      ");
            if (variant !== '*') {
                out.push("\n");
                out.push("      relName: \"" + (rel.relName) + "\",\n");
                out.push("      propName:\"" + (rel.to) + (rel.relName.split('.').join('')) + "\",\n");
                out.push("      ");
            }
            out.push("\n");
            out.push("      model: \"" + (rel.ref.thingType) + "\",\n");
            out.push("      onlyIds: true,\n");
            out.push("      conditions : params.root_" + (rel.to) + " ? _.omit(params.root_" + (rel.to) + ", ['ensure','absent']) : {},\n");
            out.push("      ensure: !params.root_" + (rel.to) + "?.absent && params.root_" + (rel.to) + " ? true : false,\n");
            out.push("      absent: !params.root_" + (rel.to) + "?.ensure && params.root_" + (rel.to) + "?.absent,\n");
            out.push("    })\n");
            out.push("  }\n");
            out.push("  ");
        });
        out.push("\n");
        out.push("\n");
        out.push("  if(cr.length > 0) query.childRel = cr\n");
        out.push("  return query\n");
        out.push("};\n");
        out.push("\n");
        out.push("global.GenericSearchQueries['ReadByQuery." + (context.$fullName) + "'] = queryForSearch\n");
        out.push("\n");
        out.push("let queryForList = function(prm){\n");
        out.push("  let q = {\n");
        out.push("    \"model\": \"" + (context.$normalizedName) + "\",\n");
        out.push("    \"options\": prm.options,\n");
        out.push("    \"conditions\": prm.root\n");
        out.push("  };\n");
        out.push("  if (prm.extKeys) { q.childRel = prm.extKeys; }\n");
        out.push("  return q;\n");
        out.push("};\n");
        out.push("\n");
        out.push("let query" + (context.$fullName) + " = global.CustomQuery.query" + (context.$fullName) + " = exports.query" + (context.$fullName) + " = function (db, prm, callback) {\n");
        out.push("  let qry = prm.query(prm);\n");
        out.push("  let notEmpty = prm.notEmpty;\n");
        out.push("  let run = new pipeline.MultiWaySwitch([\n");
        out.push("    new pipeline.Stage(function(ctx, done) {\n");
        out.push("      ComplexQuery.execQueryList(db, qry, function(err, data) {\n");
        out.push("        if (!err) {\n");
        out.push("          ctx.data = data;\n");
        out.push("        }\n");
        out.push("        done(err);\n");
        out.push("      });\n");
        out.push("    }),\n");
        out.push("    new pipeline.Stage(function(ctx, done) {\n");
        out.push("      ComplexQuery.execQueryCount(db, qry, function(err, data) {\n");
        out.push("        if (!err) {\n");
        out.push("          ctx.total = data;\n");
        out.push("        }\n");
        out.push("        done(err);\n");
        out.push("      });\n");
        out.push("    })\n");
        out.push("  ]);\n");
        out.push("  run.execute(new Context({}), function(err, ctx) {\n");
        out.push("    if (err) {\n");
        out.push("      return callback(err);\n");
        out.push("    } else {\n");
        out.push("      // let result = {\n");
        out.push("      //   data: ctx.data ? ctx.data : [],\n");
        out.push("      //   total: ctx.total\n");
        out.push("      // };\n");
        out.push("\n");
        out.push("      const data = ctx.data ? ctx.data : []\n");
        out.push("      const total = data.length == qry.options.limit ? ctx.total : (qry.options.skip ?? 0) + data.length\n");
        out.push("\n");
        out.push("      let result = {\n");
        out.push("        data,\n");
        out.push("        total,\n");
        out.push("      }\n");
        out.push("      let rels;\n");
        out.push("      if (qry.childRel && typeof(qry.childRel) === 'object') rels = (qry.childRel && typeof(qry.childRel) === 'object') ? Object.keys(qry.childRel) : [];\n");
        out.push("      else if (qry.childRel && typeof(qry.childRel) === 'object') rels = (qry.childRel && typeof(qry.childRel) === 'string') ? qry.childRel.split(' ') : [];\n");
        out.push("      if (notEmpty && ctx.data.length === 0) {\n");
        out.push("        err = new Error(prm.emptyErrorMsg);\n");
        out.push("      }\n");
        out.push("      callback(err, result, rels);\n");
        out.push("    }\n");
        out.push("  });\n");
        out.push("};\n");
        out.push("Ext.directFn({\n");
        out.push("  serverModel: '" + (context.$normalizedName) + "',\n");
        out.push("  namespace: 'ReadByQuery',\n");
        out.push("  name: '" + (context.$fullName) + "',\n");
        out.push("  locationType:\"" + (context.locationType) + "\",\n");
        out.push("  body: function(para) {\n");
        out.push("    let search = para.search ?? false;\n");
        out.push("    let context = this;\n");
        out.push("    let prm = para.data.shift();\n");
        out.push("    let cond = {};\n");
        out.push("    let qOptions = {\n");
        out.push("    ");
        if (!(context.derivedProperties && context.derivedProperties.length > 0)) {
            out.push("\n");
            out.push("      //lean:true disabled for future only when we change the code generation engine\n");
            out.push("    ");
        }
        out.push("\n");
        out.push("    };\n");
        out.push("    let limit = (prm.hasOwnProperty('limit') && typeof prm.limit === 'number' && prm.limit > 0) ? prm.limit : 0;\n");
        out.push("    let skip = prm.start;\n");
        out.push("    let sort = Ext.decodeSort(prm.sort);\n");
        out.push("    // check if we need to load related ids for specific associations\n");
        out.push("    let extKeys = Ext.decodeExtKeys(prm);\n");
        out.push("    if (limit) qOptions.limit = limit;\n");
        out.push("    if (skip && limit) qOptions.skip = skip;\n");
        out.push("    if (typeof(sort) ==='object' && Object.keys(sort).length > 0) qOptions.sort = sort;\n");
        out.push("    let loadRecord = prm.full ? true : false;\n");
        out.push("    let relHash = {\n");
        out.push("      ");
        iterateRelGroups(allRels, (variant, rel, relIndex, variantIndex)=>{
            out.push("\n");
            out.push("        \"" + (rel.to));
            if (variant !== '*') {
                out.push((rel.relName.split('.').join('')));
            }
            out.push("\":\"" + (rel.relName) + "\",\n");
            out.push("      ");
        });
        out.push("\n");
        out.push("    };\n");
        out.push("         //перенести в кодогенерацию --> цель: улучшить синхронизацию кэшированных данных так, чтобы она не удаляла нужные атрибуты или не заменяла пустыми\n");
        out.push("    let clean = function(obj, allRels, relList) {\n");
        out.push("    // relList это те реляции которые я хочу видеть... заказал.\n");
        out.push("    // allRels это все реляции доступные в объекте...\n");
        out.push("      let anyrels = false;\n");
        out.push("      if (relList) {\n");
        out.push("        let rels = {};\n");
        out.push("        for (let i = rels.length - 1; i >= 0; i--) {\n");
        out.push("          anyrels = true;\n");
        out.push("          rels[relList[i]] = 1;\n");
        out.push("        }\n");
        out.push("      }\n");
        out.push("      let ret;\n");
        out.push("      if (obj) {\n");
        out.push("        if (obj.data && Array.isArray(obj.data)) {\n");
        out.push("          obj.data = clean(obj.data, allRels, relList);\n");
        out.push("          ret = obj;\n");
        out.push("        } else if (Array.isArray(obj)) {\n");
        out.push("          ret = obj.map(function(item) {\n");
        out.push("            return clean(item, allRels, relList);\n");
        out.push("          });\n");
        out.push("        } else {\n");
        out.push("          ret = (obj.toObject) ? obj.toObject({virtuals:true}) : obj;\n");
        out.push("          if (anyrels) {\n");
        out.push("            for (let prop in allRels) {\n");
        out.push("              if(!relList.hasOwnProperty(prop))\n");
        out.push("                delete ret[prop];\n");
        out.push("            }\n");
        out.push("          }\n");
        out.push("        }\n");
        out.push("      }\n");
        out.push("      return ret;\n");
        out.push("    };\n");
        out.push("    let callback = function(err, data, rels) {\n");
        out.push("      if (!err) context.success(data ? clean(data, relHash, rels) : []);\n");
        out.push("      else context.failure(err);\n");
        out.push("    };\n");
        out.push("    if(!search) {\n");
        out.push("      cond.options = qOptions;\n");
        out.push("      let conditions = Ext.decodeFilters(prm.conditions, relHash)\n");
        out.push("      let filters = Ext.decodeFilters(prm.filter, relHash);\n");
        out.push("      let serverFilters = Ext.decodeFilters(prm.serverFilters, relHash);\n");
        out.push("      for(let fp in serverFilters){\n");
        out.push("        filters[fp] = serverFilters[fp];\n");
        out.push("      }\n");
        out.push("\n");
        out.push("      let qry;\n");
        out.push("\n");
        out.push("      ");
        if (anyRel > 0) {
            out.push("\n");
            out.push("        let filter;\n");
            out.push("        ");
            iterateRelGroups(allNonEmbedded, (variant, rel, relIndex, variantIndex)=>{
                if (relIndex > 0 || variantIndex > 0) {
                    out.push(" else ");
                }
                out.push("\n");
                out.push("        if(filters.hasOwnProperty('" + (rel.to));
                if (variant !== '*') {
                    out.push((rel.relName.split('.').join('')));
                }
                out.push("')){\n");
                out.push("          filter = filters['" + (rel.to));
                if (variant !== '*') {
                    out.push((rel.relName.split('.').join('')));
                }
                out.push("'];\n");
                out.push("          qry = {\n");
                out.push("            model: \"" + (rel.ref.thingType) + "\",\n");
                out.push("            itemId: {\n");
                out.push("              \"" + (rel.toKeyField) + "\": filter\n");
                out.push("            },\n");
                out.push("            opposite: {\n");
                out.push("              opposite: \"" + (rel.from) + "\",\n");
                out.push("              options: qOptions,\n");
                out.push("              conditions,\n");
                out.push("              total:true,\n");
                out.push("              \"childRel\": childRel\n");
                out.push("            }\n");
                out.push("          };\n");
                out.push("\n");
                out.push("          if(extKeys) qry.extKeys = extKeys;\n");
                out.push("          queryLoadRelated(context.dbPool, qry, callback);\n");
                out.push("        }\n");
                out.push("      ");
            });
            out.push("\n");
            out.push("      else {\n");
            out.push("    ");
        }
        out.push("\n");
        out.push("      let filterKeys = (filters && typeof(filters) ==='object') ? Object.keys(filters) : [];\n");
        out.push("\n");
        out.push("      if (prm.hasOwnProperty('id')) {\n");
        out.push("        loadRecord = true;\n");
        out.push("        if(prm.id === '$$$unlink$rel$$$') prm.id = '000000000000000000000000';\n");
        out.push("        cond.root = {\n");
        out.push("          _id: prm.id\n");
        out.push("        };\n");
        out.push("        cond.notEmpty = true;\n");
        out.push("        cond.emptyErrorMsg = 'Item of " + (context.$normalizedName) + " model with specified ID (' + prm.id + ') is not found.';\n");
        out.push("      } else {\n");
        out.push("        if(filterKeys.length > 0){\n");
        out.push("          // delete cond.options.skip;\n");
        out.push("          // delete cond.options.limit;\n");
        out.push("          let len = filterKeys.length;\n");
        out.push("          if (!cond.root) cond.root = {};\n");
        out.push("          for (let i = 0; i < len; i++) {\n");
        out.push("            cond.root[filterKeys[i]] = filters[filterKeys[i]];\n");
        out.push("          }\n");
        out.push("          if('id' in cond.root) {\n");
        out.push("            cond.root._id = cond.root.id\n");
        out.push("            cond.root.id = undefined\n");
        out.push("          }\n");
        out.push("          loadRecord = '_id' in cond.root;\n");
        out.push("        }\n");
        out.push("      }\n");
        out.push("\n");
        out.push("      if(extKeys) cond.extKeys = extKeys;\n");
        out.push("      // load Full Record Only(!!!) when id is present.\n");
        out.push("      cond.query = loadRecord ? queryForDetail : queryForList;\n");
        out.push("\n");
        out.push("      global.CustomQuery['query" + (context.$fullName) + "'](context.dbPool, cond, callback);\n");
        out.push("    ");
        if (anyRel > 0) {
            out.push("\n");
            out.push("      }\n");
            out.push("    ");
        }
        out.push("\n");
        out.push("    } else {\n");
        out.push("      global.CustomQuery['query" + (context.$fullName) + "'](context.dbPool, { ... prm, search: prm.query, query: queryForSearch, options: qOptions }, callback);\n");
        out.push("    }\n");
        out.push("  }\n");
        out.push("});");
        return out.join('');
    },
    compile: function() {},
    dependency: {}
};

//# sourceMappingURL=generators/server/Meta.Thing/ext.model.direct.old.njs.js.map