{"version":3,"sources":["generators/server/Meta.Relation/relation.classic.njs.js"],"names":["text","code","expression"],"mappings":"AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IACCA,+BACAA,sEACAA,4EACAA,mCACAA,iCACAA,mCACAA,mCACAA,2BACAA,IACAC;AAVD,IAUCA,AACAA;AAXD,IAWCA,AACAA;AAZD,IAYCA,AACAA;AAbD,IAaCA,AACAA;AAdD,IAcCA,AACAA;AAfD,IAeCA,AACAA;AAhBD,IAgBCA,AACAA;AAjBD,IAiBCA,AACAA;AAlBD,IAkBCA,AACAA;AAnBD,IAmBCA,AACAA;AApBD,IAoBCA,AACAA;AArBD,IAqBCA,AACAA;AAtBD,IAsBCA,AACAA;AAvBD,IAuBCA,AACAA;AAxBD,IAwBCA,AACAA;AAzBD,IAyBCA,AACAA;AA1BD,IA0BCA,AACAA;AA3BD,IA2BCA,AACAA;AA5BD,IA4BCA,AACAA;AA7BD,IA6BCA,AACAA;AA9BD,IA8BCA,AACAA;AA/BD,IA+BCA,AACAA;AAhCD,IAgCCA,AACAA;AAjCD,IAiCCA,AACAA;AAlCD,IAkCCA,AACAA;AAnCD,IAmCCA,AACAA;AApCD,IAoCCA,AACAA;AArCD,IAqCCA,AACAA;AAtCD,IAsCCA,AACAA;AAvCD,IAuCCA,AACAA;AAxCD,IAwCCA,AACAA;AAzCD,IAyCCA,AACAA;AA1CD,IA0CCA,AACAA;AA3CD,IA2CCA,AACAA;AA5CD,IA4CCA,AACAA;AA7CD,IA6CCA,AACAA;AA9CD,IA8CCA,AACAA;AA/CD,IA+CCA,AACAA;AAhDD,IAgDCA,AACAA;AAjDD,IAiDCA,AACAA;AAlDD,IAkDCA,AAAED,IACFA,KAAGE,SAAUF,OACbC;AApDD,IAoDCA,AACAA;AArDD,IAqDCA,AACAA;AAtDD,IAsDCA,AACAA;AAvDD,IAuDCA,AACAA;AAxDD,IAwDCA,AACAA;AAzDD,IAyDCA,AAAED,IACFA,IACAA,OAAKE,YAAaF,QAClBA,oCAAkCE,cAAeF,gCACjDA,IAAEE,qBAAsBF,UAAQE,OAAQF,mBAAiBE,iBAAkBF,yBAC3EA,IAAEE,mBAAoBF,UAAQE,OAAQF,mBAAiBE,iBAAkBF,wBACzEA,MACAA,IACAA,OAAKE,YAAaF,iBAAeE,YAAaF,gBAAcE,wBAAyBF,yBACrFA,IACAA,GAACE,YAAaF,8CACdA,GAACE,YAAaF,mDACdA,IACAA,oDACAA,yBAAuBE,mBAAoBF,uBAAqBE,mBAAoBF,UACpFA,IACAA,qBAAmBE,cAAeF,MAAIE,YAAaF,KACnDA,IACAA,GAACE,YAAaF,YACdA,KAAGE,qBAAsBF,SACzBA,MAAGE,mBAAoBF,SACvBA,QACAA,kDACAA,OACAA,IACAA,IACAA,uDACAA,cAAYE,mBAAoBF,kBAAgBE,mBAAoBF,UACpEA,oCAAkCE,cAAeF,sBAAoBE,cAAeF,MACpFA,IACAA,IAAEE,eAAgBF,wCAAsCE,cAAeF,uBAAqBE,cAAeF,wBAAsBE,cAAeF,MAChJA,OACAA,IACAA,kDAAgDE,sBAAuBF,YAAUE,cAAeF,QAChGA,IACAC;AA5FD,IA4FCA,AAAMD,IACNA,IACAC;AA9FD,IA8FCA,AACAA;AA/FD,IA+FCA,AACAA;AAhGD,IAgGCA,AACAA;AAjGD,IAiGCA,AACAA;AAlGD,IAkGCA,AACAA;AAnGD,IAmGCA,AACAA;AApGD,IAoGCA,AACAA;AArGD,IAqGCA,AACAA;AAtGD,IAsGCA,AACAA;AAvGD,IAuGCA,AACAA;AAxGD,IAwGCA,AAAED,IACFA,uBAAqBE,8KAA+KF,KACpMA,IACAC;AA3GD,IA2GCA,AAA2BD,IAC3BA,2BACAC;AA7GD,IA6GCA,AACAA;AA9GD,IA8GCA,AACAA;AA/GD,IA+GCA,AACAA;AAhHD,IAgHCA,AACAA;AAjHD,IAiHCA,AACAA;AAlHD,IAkHCA,AACAA;AAnHD,IAmHCA,AAA2CD,IAC3CC;AApHD,IAoHCA,AACAA;AArHD,IAqHCA,AACAA;AAtHD,IAsHCA,AAAED,IACFA,IACAC;AAxHD,IAwHCA,AAA6BD,IAC7BA,gCAA8BE,qBAAsBF,kBACpDA,wCAAsCE,qBAAsBF,MAC5DA,mBACAA,cAAYE,gDAAiDF,KAC7DA,kBAAgBE,iCAAkCF,KAClDA,QAAME,eAAgBF,UACtBA,qBACAA,UACAA,yBAAuBE,qBAAsBF,UAAOE,cAAeF,KAAEC;AAjItE,IAiIsEA,AAAaD,GAACC;AAjIpF,IAiIoFA,AAAKD,KAAGC;AAjI5F,IAiI4FA,AAAaD,GAACC;AAjI1G,IAiI0GA,AAAKD,OAC9GA,OACAC;AAnID,IAmICA,AACAA;AApID,IAoICA,AACAA;AArID,IAqICA,AACAA;AAtID,IAsICA,AACAA;AAvID,IAuICA,AAAED,IACFA,gCAA8BE,OAAQF,kBACtCA,wCAAsCE,OAAQF,MAC9CA,mBACAA,cAAYE,gDAAiDF,KAC7DA,kBAAgBE,iCAAkCF,KAClDA,QAAME,eAAgBF,UACtBA,qBACAA,UACAA,yBAAuBE,OAAQF,UAAOE,cAAeF,KAAEC;AAhJxD,IAgJwDA,AAAaD,GAACC;AAhJtE,IAgJsEA,AAAKD,KAAGC;AAhJ9E,IAgJ8EA,AAAaD,GAACC;AAhJ5F,IAgJ4FA,AAAKD,OAChGA,OACAC;AAlJD,IAkJCA,AAAKD,IACLC;AAnJD,IAmJCA,AAAKD,IACLC;AApJD,IAoJCA,AAAKD,IACLC;AArJD,IAqJCA;AArJD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","file":"generators/server/Meta.Relation/relation.classic.njs.js","sourceRoot":"/Users/vedmalex/work/fte2/demo","sourcesContent":["<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"],"template":{"version":"1.0.0","segments":[{"generatedLine":1,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":2,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":3,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":4,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":5,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":6,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":7,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":8,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":9,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":10,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":11,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":12,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":13,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":14,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":15,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":16,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":17,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":18,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":19,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":20,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":21,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":22,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":23,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":24,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":25,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":26,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":27,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":28,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":29,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":30,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":31,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":32,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":33,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":34,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":35,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":36,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":37,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":38,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":39,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":40,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":41,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":42,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":43,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":44,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":45,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":46,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":47,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":48,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":49,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":50,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":51,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":52,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":53,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":54,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":55,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":56,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":57,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":58,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":59,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":60,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":61,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":62,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":63,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":64,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":65,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":66,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":67,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":68,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":69,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":70,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":71,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":72,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":73,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":74,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":75,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":76,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":77,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":78,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":79,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":80,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":81,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":82,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":83,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":84,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":85,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":86,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":87,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":88,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":89,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":90,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":91,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":92,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":93,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":94,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":95,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":96,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":97,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":98,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":99,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":100,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":101,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":102,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":103,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":104,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":105,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":106,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":107,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":108,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":109,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":110,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":111,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":112,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":113,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":114,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":115,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":116,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":117,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":118,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":119,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":120,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":121,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":122,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":123,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":124,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":125,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":126,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":127,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":128,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":129,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":130,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":131,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":132,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":133,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":134,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":135,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":136,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":137,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":138,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":139,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":140,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":141,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":142,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":143,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":144,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":145,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":146,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":147,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":148,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":149,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":150,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":151,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":152,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":153,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":154,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":155,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":156,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":157,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":158,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":159,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":160,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":161,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":162,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":163,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":164,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":165,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":166,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":167,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":168,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":169,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":170,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":171,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":172,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":173,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":174,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":175,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":176,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":177,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":178,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":179,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":180,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":181,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":182,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":183,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":184,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":185,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":186,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":187,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":188,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":189,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":190,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":191,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":192,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":193,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":194,"generatedColumn":0,"originalLine":1,"originalColumn":0,"source":"generators/server/Meta.Relation/relation.classic.njs.js"},{"generatedLine":8,"generatedColumn":4,"originalLine":2,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":8,"generatedColumn":35,"originalLine":3,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":8,"generatedColumn":105,"originalLine":4,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":8,"generatedColumn":181,"originalLine":5,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":8,"generatedColumn":216,"originalLine":6,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":8,"generatedColumn":249,"originalLine":7,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":8,"generatedColumn":284,"originalLine":8,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":8,"generatedColumn":319,"originalLine":9,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":8,"generatedColumn":346,"originalLine":10,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":8,"generatedColumn":350,"originalLine":11,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":9,"generatedColumn":4,"originalLine":11,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":9,"generatedColumn":4,"originalLine":12,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":10,"generatedColumn":4,"originalLine":12,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":10,"generatedColumn":4,"originalLine":13,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":11,"generatedColumn":4,"originalLine":13,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":11,"generatedColumn":4,"originalLine":14,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":12,"generatedColumn":4,"originalLine":14,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":12,"generatedColumn":4,"originalLine":15,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":13,"generatedColumn":4,"originalLine":15,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":13,"generatedColumn":4,"originalLine":16,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":14,"generatedColumn":4,"originalLine":16,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":14,"generatedColumn":4,"originalLine":17,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":15,"generatedColumn":4,"originalLine":17,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":15,"generatedColumn":4,"originalLine":18,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":16,"generatedColumn":4,"originalLine":18,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":16,"generatedColumn":4,"originalLine":19,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":17,"generatedColumn":4,"originalLine":19,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":17,"generatedColumn":4,"originalLine":20,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":18,"generatedColumn":4,"originalLine":20,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":18,"generatedColumn":4,"originalLine":21,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":19,"generatedColumn":4,"originalLine":21,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":19,"generatedColumn":4,"originalLine":22,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":20,"generatedColumn":4,"originalLine":22,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":20,"generatedColumn":4,"originalLine":23,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":21,"generatedColumn":4,"originalLine":23,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":21,"generatedColumn":4,"originalLine":24,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":22,"generatedColumn":4,"originalLine":24,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":22,"generatedColumn":4,"originalLine":25,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":23,"generatedColumn":4,"originalLine":25,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":23,"generatedColumn":4,"originalLine":26,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":24,"generatedColumn":4,"originalLine":26,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":24,"generatedColumn":4,"originalLine":27,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":25,"generatedColumn":4,"originalLine":27,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":25,"generatedColumn":4,"originalLine":28,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":26,"generatedColumn":4,"originalLine":28,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":26,"generatedColumn":4,"originalLine":29,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":27,"generatedColumn":4,"originalLine":29,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":27,"generatedColumn":4,"originalLine":30,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":28,"generatedColumn":4,"originalLine":30,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":28,"generatedColumn":4,"originalLine":31,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":29,"generatedColumn":4,"originalLine":31,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":29,"generatedColumn":4,"originalLine":32,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":30,"generatedColumn":4,"originalLine":32,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":30,"generatedColumn":4,"originalLine":33,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":31,"generatedColumn":4,"originalLine":33,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":31,"generatedColumn":4,"originalLine":34,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":32,"generatedColumn":4,"originalLine":34,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":32,"generatedColumn":4,"originalLine":35,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":33,"generatedColumn":4,"originalLine":35,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":33,"generatedColumn":4,"originalLine":36,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":34,"generatedColumn":4,"originalLine":36,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":34,"generatedColumn":4,"originalLine":37,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":35,"generatedColumn":4,"originalLine":37,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":35,"generatedColumn":4,"originalLine":38,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":36,"generatedColumn":4,"originalLine":38,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":36,"generatedColumn":4,"originalLine":39,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":37,"generatedColumn":4,"originalLine":39,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":37,"generatedColumn":4,"originalLine":40,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":38,"generatedColumn":4,"originalLine":40,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":38,"generatedColumn":4,"originalLine":41,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":39,"generatedColumn":4,"originalLine":41,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":39,"generatedColumn":4,"originalLine":42,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":40,"generatedColumn":4,"originalLine":42,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":40,"generatedColumn":4,"originalLine":43,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":41,"generatedColumn":4,"originalLine":43,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":41,"generatedColumn":4,"originalLine":44,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":42,"generatedColumn":4,"originalLine":44,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":42,"generatedColumn":4,"originalLine":45,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":43,"generatedColumn":4,"originalLine":45,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":43,"generatedColumn":4,"originalLine":46,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":44,"generatedColumn":4,"originalLine":46,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":44,"generatedColumn":4,"originalLine":47,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":45,"generatedColumn":4,"originalLine":47,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":45,"generatedColumn":4,"originalLine":48,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":46,"generatedColumn":4,"originalLine":48,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":46,"generatedColumn":4,"originalLine":49,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":47,"generatedColumn":4,"originalLine":49,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":47,"generatedColumn":4,"originalLine":50,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":48,"generatedColumn":4,"originalLine":50,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":48,"generatedColumn":4,"originalLine":51,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":49,"generatedColumn":4,"originalLine":51,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":49,"generatedColumn":4,"originalLine":51,"originalColumn":3,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":49,"generatedColumn":8,"originalLine":52,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":49,"generatedColumn":13,"originalLine":52,"originalColumn":4,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":49,"generatedColumn":22,"originalLine":52,"originalColumn":14,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":49,"generatedColumn":29,"originalLine":53,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":50,"generatedColumn":4,"originalLine":53,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":50,"generatedColumn":4,"originalLine":54,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":51,"generatedColumn":4,"originalLine":54,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":51,"generatedColumn":4,"originalLine":55,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":52,"generatedColumn":4,"originalLine":55,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":52,"generatedColumn":4,"originalLine":56,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":53,"generatedColumn":4,"originalLine":56,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":53,"generatedColumn":4,"originalLine":57,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":54,"generatedColumn":4,"originalLine":57,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":54,"generatedColumn":4,"originalLine":58,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":4,"originalLine":58,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":4,"originalLine":58,"originalColumn":3,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":8,"originalLine":59,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":12,"originalLine":60,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":19,"originalLine":60,"originalColumn":6,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":31,"originalLine":60,"originalColumn":19,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":39,"originalLine":61,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":75,"originalLine":61,"originalColumn":35,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":89,"originalLine":61,"originalColumn":50,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":121,"originalLine":62,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":125,"originalLine":62,"originalColumn":3,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":146,"originalLine":62,"originalColumn":25,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":156,"originalLine":62,"originalColumn":33,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":163,"originalLine":62,"originalColumn":41,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":182,"originalLine":62,"originalColumn":58,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":199,"originalLine":62,"originalColumn":76,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":224,"originalLine":63,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":228,"originalLine":63,"originalColumn":3,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":247,"originalLine":63,"originalColumn":23,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":257,"originalLine":63,"originalColumn":31,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":264,"originalLine":63,"originalColumn":39,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":283,"originalLine":63,"originalColumn":56,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":300,"originalLine":63,"originalColumn":74,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":324,"originalLine":64,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":330,"originalLine":65,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":334,"originalLine":66,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":341,"originalLine":66,"originalColumn":6,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":353,"originalLine":66,"originalColumn":19,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":370,"originalLine":66,"originalColumn":34,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":382,"originalLine":66,"originalColumn":47,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":398,"originalLine":66,"originalColumn":61,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":422,"originalLine":66,"originalColumn":86,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":447,"originalLine":67,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":451,"originalLine":68,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":454,"originalLine":68,"originalColumn":2,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":466,"originalLine":68,"originalColumn":15,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":512,"originalLine":69,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":515,"originalLine":69,"originalColumn":2,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":527,"originalLine":69,"originalColumn":15,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":578,"originalLine":70,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":582,"originalLine":71,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":634,"originalLine":72,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":659,"originalLine":72,"originalColumn":24,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":678,"originalLine":72,"originalColumn":44,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":701,"originalLine":72,"originalColumn":65,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":720,"originalLine":72,"originalColumn":85,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":730,"originalLine":73,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":734,"originalLine":74,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":755,"originalLine":74,"originalColumn":20,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":769,"originalLine":74,"originalColumn":35,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":775,"originalLine":74,"originalColumn":39,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":787,"originalLine":74,"originalColumn":52,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":792,"originalLine":75,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":796,"originalLine":76,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":799,"originalLine":76,"originalColumn":2,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":811,"originalLine":76,"originalColumn":15,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":823,"originalLine":77,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":828,"originalLine":77,"originalColumn":4,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":849,"originalLine":77,"originalColumn":26,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":858,"originalLine":78,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":864,"originalLine":78,"originalColumn":4,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":883,"originalLine":78,"originalColumn":24,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":892,"originalLine":79,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":900,"originalLine":80,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":950,"originalLine":81,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":957,"originalLine":82,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":961,"originalLine":83,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":965,"originalLine":84,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1020,"originalLine":85,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1034,"originalLine":85,"originalColumn":13,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1053,"originalLine":85,"originalColumn":33,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1071,"originalLine":85,"originalColumn":49,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1090,"originalLine":85,"originalColumn":69,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1100,"originalLine":86,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1136,"originalLine":86,"originalColumn":35,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1150,"originalLine":86,"originalColumn":50,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1172,"originalLine":86,"originalColumn":70,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1186,"originalLine":86,"originalColumn":85,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1192,"originalLine":87,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1196,"originalLine":88,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1200,"originalLine":88,"originalColumn":3,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1215,"originalLine":88,"originalColumn":19,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1255,"originalLine":88,"originalColumn":57,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1269,"originalLine":88,"originalColumn":72,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1292,"originalLine":88,"originalColumn":93,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1306,"originalLine":88,"originalColumn":108,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1330,"originalLine":88,"originalColumn":130,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1344,"originalLine":88,"originalColumn":145,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1350,"originalLine":89,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1357,"originalLine":90,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1361,"originalLine":91,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1411,"originalLine":91,"originalColumn":49,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1433,"originalLine":91,"originalColumn":72,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1445,"originalLine":91,"originalColumn":82,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1459,"originalLine":91,"originalColumn":97,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1467,"originalLine":92,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":55,"generatedColumn":1471,"originalLine":93,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":56,"generatedColumn":4,"originalLine":93,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":56,"generatedColumn":4,"originalLine":93,"originalColumn":7,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":56,"generatedColumn":8,"originalLine":94,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":56,"generatedColumn":12,"originalLine":95,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":57,"generatedColumn":4,"originalLine":95,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":57,"generatedColumn":4,"originalLine":96,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":58,"generatedColumn":4,"originalLine":96,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":58,"generatedColumn":4,"originalLine":97,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":59,"generatedColumn":4,"originalLine":97,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":59,"generatedColumn":4,"originalLine":98,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":60,"generatedColumn":4,"originalLine":98,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":60,"generatedColumn":4,"originalLine":99,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":61,"generatedColumn":4,"originalLine":99,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":61,"generatedColumn":4,"originalLine":100,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":62,"generatedColumn":4,"originalLine":100,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":62,"generatedColumn":4,"originalLine":101,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":63,"generatedColumn":4,"originalLine":101,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":63,"generatedColumn":4,"originalLine":102,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":64,"generatedColumn":4,"originalLine":102,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":64,"generatedColumn":4,"originalLine":103,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":65,"generatedColumn":4,"originalLine":103,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":65,"generatedColumn":4,"originalLine":104,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":66,"generatedColumn":4,"originalLine":104,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":66,"generatedColumn":4,"originalLine":105,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":67,"generatedColumn":4,"originalLine":105,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":67,"generatedColumn":4,"originalLine":105,"originalColumn":3,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":67,"generatedColumn":8,"originalLine":106,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":67,"generatedColumn":31,"originalLine":106,"originalColumn":22,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":67,"generatedColumn":205,"originalLine":106,"originalColumn":197,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":67,"generatedColumn":210,"originalLine":107,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":67,"generatedColumn":214,"originalLine":108,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":68,"generatedColumn":4,"originalLine":108,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":68,"generatedColumn":4,"originalLine":108,"originalColumn":28,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":68,"generatedColumn":8,"originalLine":109,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":68,"generatedColumn":35,"originalLine":110,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":69,"generatedColumn":4,"originalLine":110,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":69,"generatedColumn":4,"originalLine":111,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":70,"generatedColumn":4,"originalLine":111,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":70,"generatedColumn":4,"originalLine":112,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":71,"generatedColumn":4,"originalLine":112,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":71,"generatedColumn":4,"originalLine":113,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":72,"generatedColumn":4,"originalLine":113,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":72,"generatedColumn":4,"originalLine":114,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":73,"generatedColumn":4,"originalLine":114,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":73,"generatedColumn":4,"originalLine":115,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":74,"generatedColumn":4,"originalLine":115,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":74,"generatedColumn":4,"originalLine":116,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":75,"generatedColumn":4,"originalLine":116,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":75,"generatedColumn":4,"originalLine":116,"originalColumn":44,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":75,"generatedColumn":8,"originalLine":117,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":76,"generatedColumn":4,"originalLine":117,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":76,"generatedColumn":4,"originalLine":118,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":77,"generatedColumn":4,"originalLine":118,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":77,"generatedColumn":4,"originalLine":119,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":78,"generatedColumn":4,"originalLine":119,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":78,"generatedColumn":4,"originalLine":119,"originalColumn":3,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":78,"generatedColumn":8,"originalLine":120,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":78,"generatedColumn":12,"originalLine":121,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":4,"originalLine":121,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":4,"originalLine":121,"originalColumn":30,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":8,"originalLine":122,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":40,"originalLine":122,"originalColumn":31,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":61,"originalLine":122,"originalColumn":53,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":79,"originalLine":123,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":119,"originalLine":123,"originalColumn":39,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":140,"originalLine":123,"originalColumn":61,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":146,"originalLine":124,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":165,"originalLine":125,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":179,"originalLine":125,"originalColumn":13,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":227,"originalLine":125,"originalColumn":62,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":232,"originalLine":126,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":250,"originalLine":126,"originalColumn":17,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":283,"originalLine":126,"originalColumn":51,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":288,"originalLine":127,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":296,"originalLine":127,"originalColumn":7,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":311,"originalLine":127,"originalColumn":23,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":321,"originalLine":128,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":342,"originalLine":129,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":352,"originalLine":130,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":377,"originalLine":130,"originalColumn":24,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":398,"originalLine":130,"originalColumn":46,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":408,"originalLine":130,"originalColumn":53,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":422,"originalLine":130,"originalColumn":68,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":79,"generatedColumn":427,"originalLine":130,"originalColumn":70,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":80,"generatedColumn":4,"originalLine":130,"originalColumn":70,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":80,"generatedColumn":4,"originalLine":130,"originalColumn":83,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":80,"generatedColumn":7,"originalLine":130,"originalColumn":84,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":81,"generatedColumn":4,"originalLine":130,"originalColumn":84,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":81,"generatedColumn":4,"originalLine":130,"originalColumn":89,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":81,"generatedColumn":9,"originalLine":130,"originalColumn":92,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":82,"generatedColumn":4,"originalLine":130,"originalColumn":92,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":82,"generatedColumn":4,"originalLine":130,"originalColumn":105,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":82,"generatedColumn":7,"originalLine":130,"originalColumn":106,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":83,"generatedColumn":4,"originalLine":130,"originalColumn":106,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":83,"generatedColumn":4,"originalLine":130,"originalColumn":111,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":83,"generatedColumn":11,"originalLine":131,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":83,"generatedColumn":18,"originalLine":132,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":84,"generatedColumn":4,"originalLine":132,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":84,"generatedColumn":4,"originalLine":133,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":85,"generatedColumn":4,"originalLine":133,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":85,"generatedColumn":4,"originalLine":134,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":86,"generatedColumn":4,"originalLine":134,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":86,"generatedColumn":4,"originalLine":135,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":87,"generatedColumn":4,"originalLine":135,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":87,"generatedColumn":4,"originalLine":136,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":4,"originalLine":136,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":4,"originalLine":136,"originalColumn":3,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":8,"originalLine":137,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":40,"originalLine":137,"originalColumn":31,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":47,"originalLine":137,"originalColumn":39,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":65,"originalLine":138,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":105,"originalLine":138,"originalColumn":39,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":112,"originalLine":138,"originalColumn":47,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":118,"originalLine":139,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":137,"originalLine":140,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":151,"originalLine":140,"originalColumn":13,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":199,"originalLine":140,"originalColumn":62,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":204,"originalLine":141,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":222,"originalLine":141,"originalColumn":17,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":255,"originalLine":141,"originalColumn":51,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":260,"originalLine":142,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":268,"originalLine":142,"originalColumn":7,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":283,"originalLine":142,"originalColumn":23,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":293,"originalLine":143,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":314,"originalLine":144,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":324,"originalLine":145,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":349,"originalLine":145,"originalColumn":24,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":356,"originalLine":145,"originalColumn":32,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":366,"originalLine":145,"originalColumn":39,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"expression","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":380,"originalLine":145,"originalColumn":54,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":88,"generatedColumn":385,"originalLine":145,"originalColumn":56,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":89,"generatedColumn":4,"originalLine":145,"originalColumn":56,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":89,"generatedColumn":4,"originalLine":145,"originalColumn":69,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":89,"generatedColumn":7,"originalLine":145,"originalColumn":70,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":90,"generatedColumn":4,"originalLine":145,"originalColumn":70,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":90,"generatedColumn":4,"originalLine":145,"originalColumn":75,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":90,"generatedColumn":9,"originalLine":145,"originalColumn":78,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":91,"generatedColumn":4,"originalLine":145,"originalColumn":78,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":91,"generatedColumn":4,"originalLine":145,"originalColumn":91,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":91,"generatedColumn":7,"originalLine":145,"originalColumn":92,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":92,"generatedColumn":4,"originalLine":145,"originalColumn":92,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":92,"generatedColumn":4,"originalLine":145,"originalColumn":97,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":92,"generatedColumn":11,"originalLine":146,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":92,"generatedColumn":18,"originalLine":147,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":93,"generatedColumn":4,"originalLine":147,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":93,"generatedColumn":4,"originalLine":147,"originalColumn":6,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":93,"generatedColumn":8,"originalLine":148,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":94,"generatedColumn":4,"originalLine":148,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":94,"generatedColumn":4,"originalLine":148,"originalColumn":6,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":94,"generatedColumn":8,"originalLine":149,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":95,"generatedColumn":4,"originalLine":149,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":95,"generatedColumn":4,"originalLine":149,"originalColumn":6,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"text","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":95,"generatedColumn":8,"originalLine":150,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"},{"generatedLine":96,"generatedColumn":4,"originalLine":150,"originalColumn":1,"source":"generators/server/Meta.Relation/relation.classic.njs.js","name":"code","content":"<#@ noContent #>\nlet path = require('path');\nlet mongooseCreated      = require(\"@grainjs/mongoose-created\");\nlet mongooseLastModified = require(\"@grainjs/mongoose-last-modified\");\nlet mongoose = global.mongoose;\nlet Schema = mongoose.Schema;\nlet ObjectId = Schema.ObjectId;\nlet Mixed = Schema.Types.Mixed;\nlet fs = require('fs');\n\n<#\nfunction getType(name){\n  switch(name.toLowerCase()){\n    case 'int': return 'Number';\n    case 'integer': return 'Number';\n    case 'float': return 'Number';\n    case 'string': return 'String';\n    case 'date': return 'Date';\n    case 'boolean': return 'Boolean';\n    case 'objectid': return 'ObjectId';\n    case 'id': return 'ObjectId';\n    case 'stringref': return 'String';\n    default:\n      return 'Mixed'\n  }\n}\n\nlet notGenerateClass = context.source.embedded || context.dest.embedded || context.theThing;\nfunction decapitalize (str){\n  return str.charAt(0).toLowerCase() + str.slice(1);\n}\nlet dot = context.name.indexOf('.');\nlet schema = ((dot>0)? context.name.slice(dot+1):context.name);\nlet schemaName = decapitalize(schema) +'Def';\nlet resCollection = context.namespace+'.'+schema;\n\nconst relKind = `${context.source.cardinality}${context.dest.cardinality}`\n\nlet { extractRelationEndForRel, getRelIndexConfig } = require(global.USEGLOBAL('/lib/metaDataLoader'))\nconst { parentSymbol } = require(global.USEGLOBAL('schemaExport/lib/common.js'))\nlet resolver = require(global.USEGLOBAL('./genpack/resolveLocationType.js'))\n\nconst indexConfig = getRelIndexConfig(context, true)\n\nconst getChildren = thingType => (global.ThingsAllChilds\n  ? global.ThingsAllChilds[thingType]\n    ? global.ThingsAllChilds[thingType]\n    : false\n  : false)\n\n#>\n/* #{relKind} */\n<#- if(!notGenerateClass){\n\nlet sType = getType(global.ThingsProps[context.source.thingType.thingType][context.source.keyField].type);\nlet dType = getType(global.ThingsProps[context.dest.thingType.thingType][context.dest.keyField].type);\n\n#>\n\nlet $#{schemaName} = {\n  __tid: {type: String, default: '#{context.name}', index:true, sparse:true},\n '#{context.source.name}':{type:#{sType}, required:true, #{indexConfig.src}:true, sparse:true },\n '#{context.dest.name}':{type:#{dType}, required:true, #{indexConfig.dst}:true, sparse:true }\n};\n\nlet _#{schemaName} = new Schema($#{schemaName},{collection:'#{context.collectionType}', autoIndex:false});\n\n_#{schemaName}.plugin(mongooseCreated, { index: true });\n_#{schemaName}.plugin(mongooseLastModified, { index: true });\n\nif(!global.SchemaCache) global.SchemaCache = {};\nif(!global.SchemaCache.#{context.namespace}) global.SchemaCache.#{context.namespace} = {};\n\nglobal.SchemaCache.#{context.name} = _#{schemaName};\n\n_#{schemaName}.index({\n  '#{context.source.name}': 1,\n  \"#{context.dest.name}\": 1\n}, {\n  unique: true, /*dropDups:true,*/ sparse:true\n});\n\n\nglobal.RegisterSchema.jobs.push(function(mongoose){\n  if(typeof(#{context.namespace})=='undefined') #{context.namespace} = {};\n  let alreadyOverriden = !!global.#{context.name} && mongoose.model('#{context.name}')\n\n  #{resCollection} = alreadyOverriden ? mongoose.model('#{context.name}') : mongoose.model('#{context.name}', global.SchemaCache.#{context.name});\n});\n\nglobal.EnsureIndex.toBeIndexed.push({location: '#{context.locationType}', model:'#{context.name}'});\n\n<#-}#>\n\n<#-\nlet r1 = extractRelationEndForRel(context, true )\nlet r2 = extractRelationEndForRel(context, false )\nif(!r1.ref[parentSymbol].global){\n  r1 = { ...r1, ref:{...r1.ref, locationType: resolver.resolveThingLocation(r1.ref)}}\n}\nif(!r2.ref[parentSymbol].global){\n  r2 = { ...r2, ref:{...r2.ref, locationType: resolver.resolveThingLocation(r2.ref)}}\n}\nconst rels = [ r1, r2 ]\n#>\nconst rels_config = `#{JSON.stringify(rels.map(rel=>({code:rel.relationType, model:rel.model.thingType, propName: rel.propName, embedded: rel.oppositeEmbedded, ref: rel.ref.thingType})), null, 2)}`\n\n<#- if(notGenerateClass){#>\nvar reqSuccess = false;\n<#- for (let i=0; i< rels.length ;i++){\nlet rel = rels[i];\n\nconst hasChildren = getChildren(rel.model.thingType)\nconst relDef = global.RelationCache.thing[rel.model.thingType][rel.propName]\n\nconst relIsArray = Array.isArray(relDef)-#>\n<#\n\tvar many = !rel.single\n#>\n\n<#if(rel.oppositeEmbedded){#>\n\treqSuccess = RESOLVESCHEMA('#{rel.model.thingType}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{rel.model.thingType}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{rel.model.thingType}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<# var sci, child;\nvar len = hasChildren.length;\nfor (sci = 0; sci< len; sci++){\n\tchild = hasChildren[sci];\n#>\n\treqSuccess = RESOLVESCHEMA('#{child}', __dirname);\n\tif(reqSuccess && global.SchemaCache.#{child}){\n\t\tvar sch = {\n\t\t\ttype: #{rel.toKeyField === \"id\" ? 'ObjectId' : 'Mixed'},\n      required: #{rel.required ? 'true' : 'false'},\n      #{rel.index.dst}:true,\n      sparse:true\n\t\t};\n\t\tglobal.SchemaCache.#{child}.add({\"#{rel.propName}\":<#if(many){#>[<#}#>sch<#if(many){#>]<#}#>});\n\t}\n<#}#>\n<#}#>\n<#}#>\n<#}#>"}]}}