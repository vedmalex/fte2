<!-- Generated by SpecStory -->

# Оптимизация пустых блоков в коде (2025-03-11 21:44Z)

_**User**_

проанализируй, как можно убрать лишние пустые блоки
допустим main содержит из 4 блоков 3 пустых

пустой блок, это блок гда
- content = ""
- end = ""
start = ""
type = "empty"

посмотри по логике кода можно ли обойтись без них
и если можно, то как их удалить?

codeblock.njs - использует 'empty' блоки для своих целей

---

_**Assistant**_

Давайте проанализируем ситуацию:

1. В текущей реализации пустые блоки создаются в методе `process()` класса `Parser`, когда обрабатывается тип 'text':

```typescript
case 'text': {
  const actualType: ResultTypes = data || eol ? type : 'empty'
  curr.main.push({
    content: data,
    pos,
    line,
    column,
    start,
    end,
    type: actualType,
    eol,
  })
  break
}
```

2. В `codeblock.njs` есть логика, которая использует пустые блоки для определения начала и конца списка блоков:

```javascript
do {
  if(blockList.length == 0) break
  const cur = blockList.shift()
  if(cur.type !== 'empty' || (cur.type === 'text' && cur.content.trim())) {
    blockList.unshift(cur)
    break
  }
}
while(true)
```

3. Анализируя снапшоты тестов, видно что часто встречаются последовательные пустые блоки:

```javascript
{
  "column": 1,
  "content": "",
  "end": "",
  "eol": false,
  "line": 1,
  "pos": 0,
  "start": "",
  "type": "empty",
},
{
  "column": 19,
  "content": "",
  "end": "",
  "eol": false,
  "line": 1,
  "pos": 18,
  "start": "",
  "type": "empty",
},
{
  "column": 19,
  "content": "",
  "end": "",
  "eol": false,
  "line": 1,
  "pos": 18,
  "start": "",
  "type": "empty",
},
```

Предлагаю следующее решение:

1. В методе `process()` класса `Parser` можно добавить оптимизацию, которая будет объединять последовательные пустые блоки в один:

```typescript
case 'text': {
  const actualType: ResultTypes = data || eol ? type : 'empty'
  // Если текущий блок пустой и предыдущий тоже был пустым - пропускаем
  if (actualType === 'empty' && 
      curr.main.length > 0 && 
      curr.main[curr.main.length - 1].type === 'empty') {
    break;
  }
  curr.main.push({
    content: data,
    pos,
    line,
    column,
    start,
    end,
    type: actualType,
    eol,
  })
  break
}
```

Это изменение:
1. Сохранит функциональность `codeblock.njs`, так как там важно только наличие пустых блоков для определения границ, а не их количество
2. Уменьшит количество избыточных пустых блоков
3. Не нарушит логику работы парсера
4. Сделает результирующую структуру более компактной

При этом важно отметить, что полностью удалять пустые блоки нельзя, так как они используются в логике `codeblock.njs` для определения границ блоков кода и правильного форматирования вывода.

Хотите, чтобы я внес это изменение в код?

---

_**User**_

да, вноси изменения

---

_**Assistant**_

Я внесу изменения в файл `packages/fte.js-parser/src/index.ts`. Сначала давайте посмотрим на текущее содержимое релевантной части файла:

---

<details><summary>Edit file: packages/fte.js-parser/src/index.ts</summary>

undefined

**Chunk 1**
Lines added: 6, lines removed: undefined

```diff
@@ -694,4 +694,10 @@
          case 'text': {
            const actualType: ResultTypes = data || eol ? type : 'empty'
+           // Если текущий блок пустой и предыдущий тоже был пустым - пропускаем
+           if (actualType === 'empty' &&
+               curr.main.length > 0 &&
+               curr.main[curr.main.length - 1].type === 'empty') {
+             break;
+           }
            curr.main.push({
              content: data,
```

</details>

---

Отлично! Изменения внесены. Теперь:

1. Когда парсер встречает текстовый блок, он проверяет, является ли он пустым (`actualType === 'empty'`)
2. Если блок пустой, проверяется наличие предыдущего блока и его тип
3. Если предыдущий блок тоже был пустым, новый блок не добавляется
4. В результате последовательные пустые блоки будут объединены в один

Это изменение должно значительно уменьшить количество избыточных пустых блоков в выходных данных, сохраняя при этом всю необходимую функциональность для `codeblock.njs`.

Хотите, чтобы я запустил тесты, чтобы убедиться, что изменения не нарушили существующую функциональность?

---

